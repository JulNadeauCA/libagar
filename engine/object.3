.\"	$Csoft: object.3,v 1.36 2003/05/18 00:16:57 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object layer
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
The Agar game logic is built upon a tree of
.Nm
structures.
Similar to a filesystem, objects are referenced either by absolute or relative
path names.
.Pp
The
.Nm
layer implements:
.Bl -bullet -compact
.It
Memory management (paging and garbage collection)
.It
Persistence
.It
Linkage
.It
Graphical/audio data management
.It
Position/appearance on maps
.It
Dependencies
.It
Generic events and properties
.El
.Sh INITIALIZATION/LINKAGE
.nr nS 1
.Ft "struct object *"
.Fn object_new "void *parent" "const char *type" "char *name" "const void *ops"
.Pp
.Ft "void"
.Fn object_init "void *obj" "const char *type" "char *name" "const void *ops"
.Pp
.Ft int
.Fn object_load_art "void *obj" "const char *key" "int wired"
.Pp
.Ft "void"
.Fn object_attach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_detach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_move "void *oldparent" "void *child" "void *newparent"
.Pp
.Ft "char *"
.Fn object_name "void *obj"
.Pp
.Ft "void"
.Fn lock_linkage "void"
.Pp
.Ft "void"
.Fn unlock_linkage "void"
.Pp
.nr nS 0
The
.Fn object_new
function allocates, initializes and attaches a new, generic object to a parent
(if
.Fa parent
is not NULL).
.Fn object_init
initializes
.Fa obj
as an object of type
.Fa type .
The
.Fa name
string must not exceed
.Fa OBJECT_NAME_MAX
- 1 in length and
.Fa type
must not exceed
.Fa OBJECT_TYPE_MAX
- 1 in length.
.Pp
The
.Fa ops
argument, if not NULL, is a pointer to the following structure (or a derivate
of it):
.Bd -literal
struct object_ops {
	void (*init)(void *obj, char *name);		/* Initialize */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, struct netbuf *buf);	/* Load from buf */
	int  (*save)(void *obj, struct netbuf *buf);	/* Save to buf */
};
.Ed
.Pp
The
.Fn object_load_art
function searches for an archive named
.Fa key
(with the
.Sq .fob
extension) and loads graphics from it.
.Fa key
identifies a group of graphics which multiple objects can share.
These groups of graphics contain a reference count.
When this count reaches zero, the graphics are freed (they stay resident if the
.Fa wire
argument is 1).
.Fn object_load_art
returns 0 on success or -1 if an error occured.
.Pp
The
.Fn object_attach
and
.Fn object_detach
functions respectively link and unlink a
.Fa child
object against a
.Fa parent ,
and raises
.Fn attached
and
.Fn detached
events.
.Fn object_move
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
.Pp
The
.Fn object_name
function returns a copy of an object's absolute name by doing an inverse
traversal of the object tree, until the root is reached.
.Fn object_name
returns a pointer to a newly allocated, NUL-terminated string containing the
resulting pathname.
.Pp
Since
.Fn object_name
must traverse the tree backwards and the parents may change, a big lock is
required in order to protect linkage.
.Fn lock_linkage
and
.Fn unlock_linkage
acquire and release the linkage lock, respectively.
If thread safety was not enabled at compile-time, these functions are no-ops.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "void"
.Fn object_destroy "void *obj"
.Pp
.Ft "void"
.Fn object_free_events "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_props "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_childs "struct object *obj"
.Pp
.nr nS 0
The
.Fn object_destroy
function is called to free all resources reserved by
.Fa ob
and its children.
To allow static allocation of
.Nm
structures,
.Fn object_destroy
does not call
.Xr free 3 .
.Pp
.Fn object_destroy
calls
.Fn object_free_events ,
.Fn object_free_props
and
.Fn object_free_childs ,
but these functions may be called directly in order to clear the event handler
list, the property table and the attached objects, respectively.
.Sh PERSISTENCE
One of the design goals of the agar
.Nm 
system is
.Em persistence .
This is achieved by invoking object-specific
.Va load
and
.Va save
operations to write/read the state of objects (and their children) in machine
independent (network) format.
Since child objects must be allocatable and fully initializable from scratch,
an array stores the possible object types along with their structure size and
a pointer to their operation vector.
.nr nS 1
.Ft "int"
.Fn object_load "void *obj" "char *path"
.Pp
.Ft "int"
.Fn object_save "void *obj" "char *path"
.Pp
.Ft "int"
.Fn object_path "const char *name" "const char *suffix" "char *dst" \
                "size_t dst_size"
.Pp
.nr nS 0
The
.Fn object_load
function loads the state of
.Fa obj
from network format.
The data is loaded from a file at the given location if
.Fa path
is not NULL.
Otherwise, the data is loaded from the first file found in data directories
(the
.Sq path.data_path
.Xr config 3
setting).
.Pp
The
.Fn object_save
function saves the state of
.Fa obj
in network format.
The data is saved to a specific file if
.Fa path
is not NULL, otherwise it is saved in the user's data directory (the
.Sq path.user_data_dir
.Xr config 3
setting).
.Pp
Both
.Fn object_load
and
.Fn object_save
return 0 on success or -1 if an error occured.
.Pp
The
.Fn object_path
function searches the data directories for a file matching the
.Fa name
and
.Fa suffix
arguments.
If a file is found, up to
.Fa dst_size
- 1 bytes of its path name are copied to
.Fa dst ,
and the result is NUL-terminated.
.Fn object_path
returns 0 on success or -1 if an error occured.
.Sh MAP OPERATIONS
The illusion of objects (such as characters) moving inside a
.Xr map 3
is achieved by maintaining a copy of the object's current submap (a pointer to a
.Xr map 3
structure associated with the object).
Most moving game characters provide submaps called
.Sq [nswe]-idle
and
.Sq [nswe]-move ,
for instance.
The
.Nm
layer is responsible for keeping the submap copy in sync, and adjusting the
motion offsets of its noderefs in response to movement.
.nr nS 1
.Ft "int"
.Fn object_set_submap "void *obj" "char *map_name"
.Pp
.Ft "void"
.Fn object_load_submap "void *obj" "char *map_name"
.Pp
.Ft "void"
.Fn object_set_position "void *obj" "struct map *map" "int x" "int y" \
                        "int layer"
.Pp
.Ft "void"
.Fn object_unset_position "void *obj"
.Pp
.Ft "void"
.Fn object_control "void *obj" "struct input *in" "int center"
.Pp
.nr nS 0
The
.Fn object_set_submap
function searches an object's children list for a map called
.Fa map_name
and selects it.
.Fn object_set_submap
returns 0 on success or -1 on failure.
.Fn object_load_submap
initializes and loads a submap called
.Fa map_name .
.Pp
The
.Fn object_set_position
function sets the object's unique position to the given coordinates of
.Fa map .
.Fn object_unset_position
causes an object to vanish from its current position, if there is any.
.Pp
The
.Fn object_control
function assigns the input device
.Fa in
to the position associated with
.Fa obj ,
centering the view and enabling soft-scrolling if
.Fa center
is non-zero .
.Sh DEPENDENCY TABLES
These functions load/save arrays of structures containing each:
.Bl -bullet -compact -enum
.It
An object name string.
.It
An object type string.
.It
A reference count.
.El
.Pp
This allows load/save routines to keep track of an object's dependencies,
as well as to encode object references using indexes.
.Pp
.nr nS 1
.Ft "void"
.Fn object_table_init "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_destroy "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_insert "struct object_table *table" "struct object *obj"
.Pp
.Ft "void"
.Fn object_table_save "struct object_table *table" "struct netbuf *buf"
.Pp
.Ft "int"
.Fn object_table_load "struct object_table *table" "struct netbuf *buf" \
                      "char *objname"
.Pp
.nr nS 0
The
.Fn object_table_init
function initializes
.Fa table
as a new, empty dependency table.
.Fn object_table_destroy
frees the resources allocated by
.Fa table .
.Pp
The
.Fn object_table_insert
function inserts
.Fa obj
in
.Fa table ,
if it is not already there.
.Pp
The
.Fn object_table_save
function writes
.Fa table
to
.Fa buf .
The
.Fn object_table_load
reads dependencies from
.Fa buf
into
.Fa table ,
and returns 0 on success or -1 if an error occured.
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void *parent"
The object has been attached to a
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void *parent"
The object has been detached from its
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn moved "void *oldparent" "void *newparent"
The object has been moved from
.Fa oldparent
to
.Fa newparent .
The linkage lock is held during the execution of the event handler.
.El
.Sh SEE ALSO
.Xr agar 3 ,
.Xr event 3 ,
.Xr fobj 3 ,
.Xr physics 3 ,
.Xr prop 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
