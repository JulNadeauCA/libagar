.\"	$Csoft: object.3,v 1.20 2002/12/26 07:11:41 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002 CubeSoft Communications, Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Neither the name of CubeSoft Communications, nor the names of its
.\"    contributors may be used to endorse or promote products derived from
.\"    this software without specific prior written permission.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.Sh NAME
.Nm object
.Nd agar object layer
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
#include <engine/map.h>
#include <engine/input.h>
.Ed
.Sh DESCRIPTION
The agar
.Nm
layer implements:
.Pp
.Bl -bullet -compact
.It
garbage collection.
.It
storage of sprite/animations or audio.
.It
tile mapping (for map edition).
.It
saving states to network format.
.It
loading states from network format.
.It
positions on maps (back references).
.It
dependencies.
.El
.Sh INITIALIZATION
.nr nS 1
.Ft "void"
.Fn object_new "char *type" "char *name" "char *archive" "int flags" \
               "const void *ops"
.Ft "void"
.Fn object_init "struct object *ob" "char *type" "char *name" "char *archive" \
                "int flags" "const void *ops"
.Pp
.Ft "void"
.Fn object_destroy "void *ob"
.nr nS 0
.Pp
The
.Fn object_new
function allocates, initializes and attaches a new, generic object to the
world.
The
.Fn object_init
function initializes
.Fa ob
as an object of type
.Fa type
(an arbitrary string identifier describing the type of structure)
.Pp
If
.Fa archive
is not null, it identifies a
.Xr fobj 3
(with the
.Sq .fob
suffix) to be looked up in the data directories (the
.Sq path.data_path
setting) and loaded.
.Pp
.Fn object_destroy
is called to free all resources associated with
.Fa ob .
The
.Fa ops
argument is a pointer to the following structure:
.Bd -literal
struct object_ops {
	void	(*destroy)(void *ob);		/* Free resources */
	int	(*load)(void *ob, int fd);	/* Load from fd */
	int	(*save)(void *ob, int fd);	/* Save to fd */
};
.Ed
.Pp
The
.Fa flags
argument may contain:
.Bd -literal
#define OBJECT_ART		0x01	/* Load graphics from archive */
#define OBJECT_ART_CACHE	0x02	/* Never decrement the ref count */
#define OBJECT_ART_CAN_FAIL	0x04	/* Graphic load can fail */
#define OBJECT_AUDIO		0x08	/* Load audio from archive */
#define OBJECT_AUDIO_CACHE	0x10	/* Never decrement the ref count */
#define OBJECT_AUDIO_CAN_FAIL	0x20	/* Audio load can fail */
.Ed
.Sh SAVING STATES
.nr nS 1
.Ft "int"
.Fn object_load "void *ob"
.Pp
.Ft "int"
.Fn object_load_from "void *ob" "char *path"
.Pp
.Ft "int"
.Fn object_save "void *ob"
.Pp
.Ft "char *"
.Fn object_path "char *name" "const char *suffix"
.nr nS 0
.Pp
The
.Fn object_load
function loads the state of
.Fa ob
from the first file found in data directories.
.Fn object_loadfrom
loads the state of
.Fa ob
from the file at
.Fa path .
.Fn object_save
saves the state of
.Fa ob
to the user's data directory.
.Pp
The
.Fn object_path
function searches the data directories for a file matching the
.Fa name
and
.Fa suffix
arguments.
If the file is found, a pointer to the full pathname is returned,
otherwise a
.Dv NULL
pointer is returned and the error message may be retrieved using
.Xr error_get 3 .
.Sh MAP OPERATIONS
Agar organizes maps in such a way that an arbitrary amount of node items
(noderefs) may point to specific data inside specific objects.
Objects that wish to assume a unique position on a map need a back reference
to the map.
This back reference is defined by the
.Va pos
member of the object structure.
If
.Va pos
is not
.Dv NULL ,
it points to a structure describing the map, the node coordinates and the
noderef which represents this object.
.Pp
The noderef representing the object does not have the
.Dv NODEREF_SAVEABLE
flag set, so the noderef will not be included in
.Xr map 3
states.
Instead, the object implementations manually handle creation, loading and
saving of these noderefs.
.Pp
.nr nS 1
.Ft "void"
.Fn object_set_position "void *ob" "struct noderef *nref" "struct map *map" \
                        "Uint32 x" "Uint32 y"
.Pp
.Ft "void"
.Fn object_move "void *ob" "struct map *dst_map" "Uint32 dst_x" "Uint32 dst_y"
.Pp
.Ft "void"
.Fn object_control "void *ob" "struct input *in" "int center"
.Pp
.Ft "int"
.Fn object_vanish "void *ob"
.nr nS 0
.Pp
The
.Fn object_set_position
function points an object's position to
.Fa nref
on the node at the
.Fa x ,
.Fa y
coordinates of
.Fa map .
.Fn object_set_position
does not create any noderef but if there is currently a position, its noderef
is removed.
.Fn object_set_position
is usually called after a new noderef is created (with
.Fn node_add_sprite
or
.Fn node_add_anim ,
for example), in order to update the object's back reference.
.Pp
The
.Fn object_move
function moves
.Fa ob
from its current position to the
.Fa dst_x
and
.Fa dst_y
coordinates of
.Fa dst_map .
.Pp
The
.Fn object_control
function assigns the input device
.Fa in
to the position associated with
.Fa ob ,
centering the view and enabling soft-scrolling if
.Fa center
is non-zero .
.Pp
The
.Fn object_vanish
function removes the current position associated with
.Fa ob
by setting
.Va pos
to
.Dv NULL ,
as well as removing the associated noderef.
.Fn object_vanish
returns 0 on success, -1 on error.
.Sh OBJECT TABLES
These functions load and save arrays of object names with reference counts.
This allows load/save routines to keep dependency lists and reference objects
with indexes instead of strings.
.Pp
.nr nS 1
.Ft "struct object_table *"
.Fn object_table_new "void"
.Pp
.Ft "void"
.Fn object_table_destroy "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_insert "struct object_table *table" "struct object *obj"
.Pp
.Ft "void"
.Fn object_table_save "struct fobj_buf *buf" "struct object_table *table"
.Pp
.Ft "struct object_table *"
.Fn object_table_load "int fd" "char *objname"
.nr nS 0
.Pp
The
.Fn object_table_new
function allocates, initializes and return a new object table with 0 elements.
The
.Fn object_table_destroy
frees
.Fa table .
.Pp
The
.Fn object_table_insert
function inserts
.Fa obj
in
.Fa table .
.Pp
The
.Fn object_table_save
function write
.Fa table
to
.Fa buf .
The
.Fn object_table_load
function allocates and reads the object table from
.Fa fd .
.Sh SEE ALSO
.Xr agar 3
.Sh HISTORY
The
.Nm
interface appeared in AGAR 1.0
.\" .Sh BUGS
.\" .Sh CAVEATS
