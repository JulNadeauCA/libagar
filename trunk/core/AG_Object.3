.\"	$Csoft: object.3,v 1.82 2005/09/27 00:25:16 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003, 2004, 2005 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt AG_OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Object
.Nd agar object system
.Sh SYNOPSIS
.Bd -literal
#include <agar/core.h>
.Ed
.Sh DESCRIPTION
Agar's
.Nm
layer is responsible for handling:
.Pp
.Bl -bullet -compact -offset indent
.It
Memory management
.It
Object archiving (persistence)
.It
Interdependencies between multiple objects
.It
Object linkage
.It
Shared media (eg. graphics, audio)
.It
Event processing and scheduling
.El
.Pp
.Sh INITIALIZATION AND LINKAGE
.nr nS 1
.Ft "AG_Object *"
.Fn AG_ObjectNew "void *parent" "const char *name"
.Pp
.Ft "void"
.Fn AG_ObjectInit "void *obj" "const char *type" "const char *name" "const void *ops"
.Pp
.Ft "void"
.Fn AG_ObjectAttach "void *new_parent" "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectAttachPath "const char *parent_path" "void *child"
.Pp
.Ft "void"
.Fn AG_ObjectDetach "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectMove "void *obj" "void *new_parent"
.Pp
.Ft "void *"
.Fn AG_ObjectRoot "const void *obj"
.Pp
.Ft "void *"
.Fn AG_ObjectFindParent "const void *obj" "const char *name" "const char *type"
.Pp
.Ft "int"
.Fn AG_ObjectCopyName "const void *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn AG_LockLinkage "void"
.Pp
.Ft "void"
.Fn AG_UnlockLinkage "void"
.Pp
.nr nS 0
The
.Fn AG_ObjectNew
function allocates and initializes a new, generic AG_Object and attaches it to
.Fa parent
if not NULL.
.Pp
The
.Fn AG_ObjectInit
function initializes an AG_Object structure.
.Fa name
and
.Fa type
are truncated if they exceed
.Dv AG_OBJECT_NAME_MAX
and
.Dv AG_OBJECT_TYPE_MAX
in length, respectively.
Instances of
.Sq /
characters in
.Fa name
are replaced by
.Sq _ ,
since slash is the path name separator.
If
.Fa ops
is not NULL, it should point to the following structure:
.Bd -literal
typedef struct ag_object_ops {
	void (*init)(void *obj, const char *name);	/* Initialize */
	void (*reinit)(void *obj);			/* Free data */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, AG_Netbuf *buf);	/* Load data */
	int  (*save)(void *obj, AG_Netbuf *buf);	/* Save data */
	void *(*edit)(void *obj);			/* Edit data */
} AG_ObjectOps;
.Ed
.Pp
The
.Fn init
operation initializes an
.Nm
instance.
.Fn reinit
is reponsible for releasing data dynamically allocated by the AG_Object (eg.
.Xr AG_Map 3
nodes).
.Fn reinit
is invoked prior to rereading an AG_Object's data from disk, as part of an
.Dv AG_OBJECT_DATA
page out operation.
.Pp
The
.Fn destroy
operation releases all data allocated by the AG_Object, including data allocated
from
.Fn init .
The
.Fn destroy
operation is invoked from
.Fn AG_ObjectDestroy .
It must not free the AG_Object structure, and it does not need to bother about
placing the AG_Object data back into a consistent state.
.Pp
The
.Fn load
and
.Fn save
operations are responsible for archiving any persistent AG_Object data
(see the
.Em ARCHIVING AND PAGING
section for more information).
.Pp
If the compile-time option
.Dv EDITION
is defined, the
.Fn edit
operation is responsible for creating a new edition window for the object's
dynamic data.
For example, in the Agar-Game library, the
.Xr AG_Map 3
object creates an
.Xr AG_Mapview 3
widget and this constitutes the framework for the level editor.
In the Agar-SG library, the
.Xr SG 3
(scene graph) object creates a
.Xr SG_View 3
widget (a derivate of
.Xr AG_GLView 3 )
to display the scene.
.Pp
If other windows are to be created as part of this instance's edition process,
they should be attached to the main edition window using
.Xr AG_WindowAttach 3 .
The
.Fn edit
operation can also return other types of widgets, such as a
.Xr AG_Box 3
container.
.Pp
The following public
.Nm
flags are defined:
.Bd -literal
#define AG_OBJECT_RELOAD_PROPS   0x001 /* Don't free props before load */
#define AG_OBJECT_NON_PERSISTENT 0x002 /* Never include in saves */
#define AG_OBJECT_INDESTRUCTIBLE 0x004 /* Not destructible (advisory) */
#define AG_OBJECT_DATA_RESIDENT  0x008 /* Object data is resident (RO) */
#define AG_OBJECT_PRESERVE_DEPS  0x010 /* Don't remove dep if count=0 */
#define AG_OBJECT_STATIC         0x020 /* Don't free() after detach */
#define AG_OBJECT_READONLY       0x040 /* Disallow edition (advisory) */
#define AG_OBJECT_REOPEN_ONLOAD  0x200 /* Close/reopen editor on load */
#define AG_OBJECT_REMAIN_DATA    0x400 /* Keep data resident */
#define AG_OBJECT_REMAIN_GFX     0x800 /* Keep graphics resident */
.Ed
.Pp
The
.Dv AG_OBJECT_RELOAD_PROPS
flag prevents the
.Xr AG_Prop 3
table from being cleared as part of a load operation.
.Dv AG_OBJECT_NON_PERSISTENT
prevents this instance and its children from being archived.
If this flag is set,
.Fn AG_ObjectPageIn
and
.Fn AG_ObjectPageOut
with an argument of
.Dv AG_OBJECT_DATA
become no-ops.
.Pp
The
.Dv AG_OBJECT_INDESTRUCTIBLE
flag advises the object editor not to destroy this object instance.
.Dv AG_OBJECT_READONLY
advises the object-specific
.Va edit
operation that this instance should not be edited.
.Pp
The
.Dv AG_OBJECT_REOPEN_ONLOAD
flag causes the object's edition window
(as returned by the object's
.Sq edit
operation) and all sub-windows to be automatically destroyed and re-opened
by
.Fn AG_ObjectLoad ,
such that the editor does not need to worry about referencing dynamically
allocated object substructures that are freed by the load routine.
.Pp
The
.Dv AG_OBJECT_DATA_RESIDENT
flag is set by the
.Nm
system to indicate that the instance's dynamic data is resident.
.Pp
The
.Fn AG_ObjectAttach
and
.Fn AG_ObjectDetach
functions respectively link and unlink an object instance against another.
Prior to detaching the object,
.Fn AG_ObjectDetach
cancels scheduled
.Xr AG_Timeout 3
events (that do not have the
.Dv AG_TIMEOUT_DETACHABLE
flag set).
These operations raise
.Fn attached
and
.Fn detached
events.
If
.Fa parent
is NULL,
.Fn AG_ObjectAttach
is a no-op.
.Pp
The
.Fn AG_ObjectAttachPath
function is a variant of
.Fn AG_ObjectAttach
which looks up the parent using
.Fa parent_path .
.Pp
.Fn AG_ObjectMove
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
Unlike
.Fn AG_ObjectDetach ,
.Fn AG_ObjectMove
does not cancel scheduled timeout events.
.Pp
The
.Fn AG_ObjectRoot
function traverses the given object's ancestry and return a pointer to the root
item.
.Fn AG_ObjectFindParent
traverse the ancestry until a parent item matches the non-NULL
.Fa name
and
.Fa type
arguments.
The global object linkage must remain locked throughout the execution of both
.Fn AG_ObjectRoot
and
.Fn AG_ObjectFindParent .
.Pp
The
.Fn AG_ObjectCopyName
function copies the absolute pathname of an object instance to a fixed-size
buffer, returning 0 on success and -1 on failure.
.Pp
Since
.Fn AG_ObjectCopyName
must perform an inverse traversal of the tree, and an object instance may
move from one parent to another, the root provides a lock to protect its
linkage.
.Fn AG_LockLinkage
and
.Fn AG_UnlockLinkage
acquire and release the world's linkage lock, respectively.
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn AG_ObjectInUse "const void *obj"
.Pp
.Ft "AG_ObjectDep *"
.Fn AG_ObjectAddDep "void *obj" "void *depobj"
.Pp
.Ft "void"
.Fn AG_ObjectDelDep "void *obj" "void *depobj"
.Pp
.Ft "int"
.Fn AG_ObjectFindDep "const void *obj" "Uint32 ind" "AG_Object **objp"
.Pp
.Ft "Uint32"
.Fn AG_ObjectEncodeName "const void *obj" "const void *depobj"
.Pp
.nr nS 0
The
.Fn AG_ObjectInUse
function returns 1 if the given object is being referenced by another object
instance (which is sharing the same root).
.Pp
The
.Fn AG_ObjectAddDep
function either creates a new dependency upon
.Fa depobj ,
or increment the reference count if one exists.
.Fn AG_ObjectDelDep
decrements the reference count upon
.Fa depobj ,
removing it if it reaches 0.
.Pp
The
.Fn AG_ObjectFindDep
function resolves the given dependency.
.Fn AG_ObjectEncodeName
serializes an object reference.
.Pp
Serialized dependencies are integers which are either indexes into the object's
dependency table, or the special values 0 (NULL reference) and 1 (self
reference).
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "void"
.Fn AG_ObjectDestroy "void *obj"
.Pp
.Ft void
.Fn AG_ObjectFreeData "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeEvents "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeProps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeDeps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeChildren "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeZerodeps "AG_Object *obj"
.Pp
.nr nS 0
The
.Fn AG_ObjectDestroy
function is called to free all resources reserved by the given object instance,
including its children (assuming that they are not currently in use).
.Fn AG_ObjectDestroy
also cancels any
.Xr AG_Timeout 3
event scheduled for future execution.
To permit static allocation,
.Fn AG_ObjectDestroy
does not invoke
.Xr free 3
on the AG_Object structure.
.Pp
Internally,
.Fn AG_ObjectDestroy
invokes
.Fn AG_ObjectFreeEvents ,
.Fn AG_ObjectFreeProps ,
.Fn AG_ObjectFreeDeps
and
.Fn AG_ObjectFreeChildren ,
but these functions may be called directly in order to destroy and reinitialize
the event handler list, the property table and the child instances,
respectively.
.Pp
In addition to reinitializing the event handler table,
.Fn AG_ObjectFreeEvents
also cancels scheduled events.
.Pp
.Fn AG_ObjectFreeChildren
invokes
.Xr free 3
on an object's children (except those with the
.Dv AG_OBJECT_STATIC
flag set), assuming that none of them are in use.
.Pp
The
.Fn AG_ObjectFreeData
function invokes the
.Va reinit
operation of
.Fa obj
(if there is one) in order to free dynamic data, and clears the
.Dv AG_OBJECT_DATA_RESIDENT
flag.
For example, in the Agar-SG library, the
.Va reinit
operation of
.Xr SG 3 ,
destroys all the nodes in the graph, such that the
.Fn load
and
.Fn destroy
operations do not need to.
.Pp
The
.Fn AG_ObjectFreeZerodeps
function is used in situations where it is necessary to remove dependencies
that have a reference count of zero for the given object (and its children).
Dependencies with a reference count of zero only occur in objects that have the
.Dv AG_OBJECT_PRESERVE_DEPS
flag set.
.Sh ARCHIVING AND PAGING
.nr nS 1
.Ft "int"
.Fn AG_ObjectLoad "void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSave "const void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSaveAll "const void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectPageIn "void *obj" "enum ag_object_page_item item"
.Pp
.Ft "int"
.Fn AG_ObjectPageOut "void *obj" "enum ag_object_page_item item"
.Pp
.nr nS 0
These functions implement archiving of objects (also known as
"serialization" or "flattening" in object-oriented terminology).
Persistent information such as size, dependencies and position in the
hierarchy are encoded in a machine-independent format.
.Pp
The
.Fn load
and
.Fn save
functions of the generic operation vector are responsible for
archiving of data specific to the type of object at hand.
Except for direct subclasses of
.Nm ,
.Fn load
and
.Fn save
must invoke the
.Fn _load
and
.Fn _save
routines of their superclass.
.Pp
The
.Fn AG_ObjectLoad
function loads the state of an object instance and its descendants from
an archive.
The first file found in the search path (the colon-separated
.Sq load-path
config setting) is used.
.Fn AG_ObjectLoad
performs the following operations, in order:
.Bl -enum
.It
Cancel scheduled
.Xr AG_Timeout 3
events (that don't have the
.Dv AG_TIMEOUT_LOADABLE
flag set).
.It
Load the generic part (the
.Nm
class) of
.Fa obj
and its descendants.
Archived siblings found in the data file are each compared against the
currently attached object instances.
If a match is found, the
.Va reinit
op is called.
If there is no resident instance matching an archived object, one is
dynamically allocated and initialized using the type switch (the
.Va agTypes[]
array).
If a resident instance has no archived counterpart, it is destroyed (as
long as it is not currently in use).
.It
Resolve the dependencies of
.Fa obj
and its children, so encoded object references may be decoded in the
following step.
.It
If the object or any of its children has resident dynamic data, it is
reloaded.
.El
.Pp
The
.Fn AG_ObjectSave
function creates an archive of the given AG_Object in the save
directory (the
.Sq save-path
config setting).
The
.Fn AG_ObjectSaveAll
variant also saves child objects.
.Pp
The
.Fn AG_ObjectPageIn
function is used to fetch resources specific to an object instance.
If the resource is already resident, the reference count is incremented.
The
.Fa item
argument may be one of:
.Bd -literal
enum ag_object_page_item {
	AG_OBJECT_GFX,		/* Graphics */
	AG_OBJECT_AUDIO,	/* Audio data */
	AG_OBJECT_DATA		/* Object data */
};
.Ed
.Pp
The
.Fn AG_ObjectPageOut
function decrements the reference count on the given resource.
If the reference count reaches 0, the resource is saved to persistent media
and released.
.Pp
These functions return 0 on success or -1 if an error occured.
.Sh EVENTS
The
.Nm
mechanism generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void"
The object has been attached to another.
This event originates from the parent object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void"
The object has been detached from its parent.
The linkage lock is held during the execution of the event handler.
This event originates from the parent.
.It Fn child-attached "void"
Same as
.Fn attached ,
except that the event is sent from the child to the parent.
.It Fn child-detached "void"
Same as
.Fn detached ,
except that the event is sent from the child to the parent.
.It Fn moved "void *new_parent"
The object has been moved from its current parent to
.Fa new_parent .
The linkage lock is held during the execution of the event handler.
This event originates from the previous parent.
.It Fn renamed "void"
The object's name has changed.
.It Fn prop-added "AG_Prop *prop"
A new
.Xr AG_Prop 3
property has been added.
.It Fn prop-modified "AG_Prop *prop"
The value of the given property has been modified.
.El
.Sh NOTES
If the maximum number of references,
.Dv AG_OBJECT_DEP_MAX ,
is reached, the object instance remains resident and the reference count
is no longer incremented or decremented.
.Sh SEE ALSO
.Xr AG_Intro 3 ,
.Xr AG_Event 3 ,
.Xr AG_Prop 3 ,
.Xr AG_Timeout 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
