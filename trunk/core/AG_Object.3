.\" Copyright (c) 2001-2007 Hypertriton, Inc. <http://hypertriton.com/>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt AG_OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Object
.Nd agar object system
.Sh SYNOPSIS
.Bd -literal
#include <agar/core.h>
.Ed
.Sh DESCRIPTION
The Agar object system enables developers to implement components using
C or C++, and still provide equally good object-oriented programming support
(e.g., inheritance, virtual functions, etc) to applications in either
C or C++ (and possibly other languages).
.Pp
It also provides a number of features, such as virtual filesystems,
virtual functions, generic properties and per-object management of
resources such as timers and threads (where available).
The virtual system allows arbitrary datasets (possibly large and complex ones)
to be archived to different forms of persistent storage in an efficient manner.
.Sh INITIALIZATION AND VFS FUNCTIONS
.nr nS 1
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectNew "AG_Object *parent" "const char *name" "AG_ObjectClass *cls"
.Pp
.Ft "void"
.Fn AG_ObjectInit "AG_Object *obj" "AG_ObjectClass *cls"
.Pp
.Ft "void"
.Fn AG_ObjectInitStatic "AG_Object *obj" "AG_ObjectClass *cls"
.Pp
.Ft "void"
.Fn AG_ObjectAttach "AG_Object *new_parent" "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectAttachToNamed "AG_Object *vfsRoot" "const char *path" "AG_Object *child"
.Pp
.Ft "void"
.Fn AG_ObjectDetach "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectMove "AG_Object *obj" "AG_Object *new_parent"
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectRoot "AG_Object *obj"
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectParent "AG_Object *obj"
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectFind "AG_Object *vfsRoot" "const char *name"
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectFindF "AG_Object *vfsRoot" "const char *fmt" "..."
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectFindParent "AG_Object *obj" "const char *name" "const char *type"
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectFindChild "AG_Object *obj" "const char *name"
.Pp
.Ft "int"
.Fn AG_ObjectCopyName "AG_Object *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn AG_ObjectLock "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectUnlock "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_LockVFS "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_UnlockVFS "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectSetName "AG_Object *obj" "const char *fmt" "..."
.Pp
.Ft "void"
.Fn AG_ObjectSetClass "AG_Object *obj" "AG_ObjectClass *cls"
.Pp
.Ft "void"
.Fn AG_ObjectSetDebugFn "AG_Object *obj" "void (*fn)(void *obj, void *userPtr, void *msg)" "void *userPtr"
.Pp
.nr nS 0
The
.Fn AG_ObjectNew
function allocates and initializes a new object instance of the given class.
The object is attached to
.Fa parent ,
unless the argument is NULL.
If
.Fa name
is NULL, a unique name of the form
.Dq <class-name> #<number>
is automatically generated.
If both
.Fa parent
and
.Fa name
are specified and the parent object already has a child of the given name,
.Fn AG_ObjectNew
fails and returns NULL.
.Pp
The
.Fn AG_ObjectInit
function initializes an object of the specified class, invoking the
.Fn init
operation of every class in the inheritance hierarchy.
The
.Fn AG_ObjectInitStatic
variant automatically sets the
.Dv AG_OBJECT_STATIC
flag (see below).
.Pp
The
.Fa name
string identifies this object instance.
Object names are truncated if they exceed
.Dv AG_OBJECT_NAME_MAX
bytes in length, and may not contain
.Sq /
characters.
.Pp
The
.Fa ops
argument describes the object class.
It is a pointer to a
.Ft AG_ObjectClass
structure:
.Pp
.Bd -literal
typedef struct ag_object_ops {
	const char *name;        /* Class name */
	size_t size;             /* Size of structure */
	AG_Version ver;          /* Version numbers */

	void (*init)(void *obj);
	void (*reinit)(void *obj);
	void (*destroy)(void *obj);
	int  (*load)(void *obj, AG_DataSource *buf, const AG_Version *ver);
	int  (*save)(void *obj, AG_DataSource *buf);
	void *(*edit)(void *obj);
} AG_ObjectClass;
.Ed
.Pp
The
.Va name
member is the name of this class, where subclasses are separated by a
colon, such as
.Dq AG_Superclass:AG_Subclass .
It is implied that the root class is
.Dq AG_Object ,
so there is no need to specify it in the string.
.Pp
The
.Va size
member describes is the amount of memory that will be allocated by the object
system to hold the structure.
.Va ver
contains the version numbers that will be used in dataset archives (see
.Xr AG_Version 3
for more details).
.Pp
The
.Fn init
operation initializes an
.Nm
instance.
It invokes the
.Fn init
operation of every class in the inheritance hierarchy.
.Pp
The
.Fn reinit
operation releases any element of the dataset that has been dynamically
allocated.
.Fn reinit
is invoked by the object system:
.Pp
.Bl -bullet -compact
.It
Prior to a
.Fn load
operation where the dataset is going to be re-read from storage.
.It
Subsequent to a
.Dv PAGE_OUT
operation, to free the dataset.
.It
Prior to a
.Fn destroy
operation where the object is being completely freed.
.El
.Pp
The
.Fn destroy
operation is invoked from
.Fn AG_ObjectDestroy
to release any resources that are not handled by
.Fn reinit .
Note that
.Fn destroy
must not free the
.Nm
structure itself.
.Pp
The
.Fn load
and
.Fn save
operations are responsible for archiving the dataset (see the
.Em ARCHIVING
section for more information).
.Pp
When defined, the
.Fn edit
operation generates user interface elements allowing the user to edit
the object's dataset.
It is a generic operation, not dependent on any particular GUI library.
.Pp
If using the Agar-GUI, the
.Fn edit
operation will usually create an
.Xr AG_Window 3
or a container widget such as 
.Xr AG_Box 3 .
When other windows are created from
.Fn edit ,
they must be attached to the main window via
.Xr AG_WindowAttach 3 .
.Pp
The following public
.Nm
flags are defined:
.Bl -tag -width "AG_OBJECT_NON_PERSISTENT "
.It Dv AG_OBJECT_RELOAD_PROPS
Prevents clearing of the
.Xr AG_Prop 3
table prior to
.Fn AG_ObjectLoad .
.It Dv AG_OBJECT_NON_PERSISTENT
Disables archiving of the object and its children.
If set,
.Fn AG_ObjectSave
becomes a no-op and
.Fn AG_ObjectLoad
calls will fail.
.It Dv AG_OBJECT_INDESTRUCTIBLE
Advisory and application-specific.
.It Dv AG_OBJECT_RESIDENT
Read-only flag set by the object system to indicate that the object's dataset
is currently resident in memory.
This flag is set by
.Fn AG_ObjectNew ,
.Fn AG_ObjectLoadData
and
.Fn AG_ObjectPageIn
and is cleared by
.Fn AG_ObjectFreeDataset
and
.Fn AG_ObjectPageOut .
.It Dv AG_OBJECT_PRESERVE_DEPS
Disable automatic removal of object dependencies when reference counts
reach 0.
.It Dv AG_OBJECT_STATIC
Indicates that this object is either statically-allocated (or allocated
through another facility than
.Xr malloc 3 ) .
The
.Fn AG_ObjectDestroy
operation will not call
.Xr free 3
on the structure.
.It Dv AG_OBJECT_READONLY
Advisory and application-specific.
.It Dv AG_OBJECT_REOPEN_ONLOAD
If the object has a
.Sq edit
operation, arrange for all graphical interface elements (as returned by
.Sq edit )
to be automatically destroyed and recreated after any
.Fn AG_ObjectLoad
call.
This flag is useful for complex objects where the graphical interface
references elements of the dataset.
.It Dv AG_OBJECT_REMAIN_DATA
Prevent the object's dataset from being automatically freed (with
.Fn AG_ObjectFreeDataset )
as a result of an
.Fn AG_ObjectPageOut
call, when the reference count reaches zero.
.It Dv AG_OBJECT_DEBUG
Enable per-object debugging; application-specific.
.It Dv AG_OBJECT_NAME_ONATTACH
Request that
.Fn AG_ObjectAttach
calls automatically generates a name for the child object being attached.
The name will be unique in the parent.
.It Dv AG_OBJECT_CHLD_AUTOSAVE
Arrange for child objects to be automatically saved along with the object
when
.Fn AG_ObjectSave*
is invoked.
.El
.Pp
Objects are organized in a tree structure.
.Fn AG_ObjectAttach
attaches an object to a new parent and
.Fn AG_ObjectDetach
detaches an object from its current parent.
These operations raise
.Sq attached
and
.Sq detached
events.
Prior to detaching the object,
.Fn AG_ObjectDetach
cancels scheduled
.Xr AG_Timeout 3
events where the
.Dv AG_CANCEL_ONDETACH
flag is set.
If
.Fa parent
is NULL,
.Fn AG_ObjectAttach
is a no-op.
.Pp
.Fn AG_ObjectAttachToNamed
is a variant of
.Fn AG_ObjectAttach
which looks up the parent inside the specified VFS using the pathname
.Fa path .
.Pp
.Fn AG_ObjectMove
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent
(both must be part of the same VFS).
.Fn AG_ObjectMove
raises
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
Note that unlike with
.Fn AG_ObjectDetach ,
scheduled timeout events are not cancelled automatically.
.Pp
.Fn AG_ObjectRoot
returns a pointer to the root of the VFS which the given object is attached to.
.Pp
.Fn AG_ObjectParent
returns the immediate parent of the given object.
.Pp
The
.Fn AG_ObjectFind
and
.Fn AG_ObjectFindF
functions perform a pathname lookup on the specified VFS and return the object
if found, NULL otherwise.
.Pp
.Fn AG_ObjectFindParent
searches all parent objects of the given object for one matching the non-NULL
.Fa name
or
.Fa type
argument.
.Pp
.Fn AG_ObjectFindChild
performs a name lookup on the immediate children of the specified object and
return the matching object if found, otherwise NULL.
.Pp
The
.Fn AG_ObjectCopyName
function copies the absolute pathname of an object instance to a fixed-size
buffer, returning 0 on success and -1 on failure.
Under multithreading, the returned pathnames can be considered valid only
as long as the VFS of the object remains locked.
.Pp
The
.Fn AG_ObjectLock
and
.Fn AG_ObjectUnlock
functions acquire or release the mutex associated with the given object.
This mutex protects all read/write members of the
.Nm
structure, except
.Fa parent ,
.Fa root
and the list of child objects
.Fa cobjs
which are all considered part of the virtual filesystem and are instead
protected by
.Fn AG_LockVFS .
.Pp
In most cases, it is best to use the
.Fn AG_ObjectLock
mutex as a general-purpose locking device for subclasses of
.Nm ,
because it is guaranteed to be held during processing of events posted to the
object, or object operations such as
.Fn load
and
.Fn save .
.Pp
The
.Fn AG_LockVFS
and
.Fn AG_UnlockVFS
functions acquire or release the lock protecting the layout of the entire
virtual system which the given object is part of.
.Pp
All lock/unlock functions are turned to no-ops if
.Dv THREADS
is not enabled at compile-time.
.Pp
.Fn AG_ObjectSetName
changes the name of the given object.
If the object is attached to a VFS, it is assumed to be locked.
.Pp
.Fn AG_ObjectSetClass
changes the generic operation vector (pointer to
.Ft AG_ObjectClass
structure) associated with the given object.
This function is not thread-safe.
.Pp
.Fn AG_ObjectSetDebugFn
specifies a function to process debug messages (as issued by
.Xr AG_Debug 3 )
for the object.
This function is a no-op unless Agar was compiled with the
.Dv DEBUG
option.
.Sh CLASS INFORMATION
.nr nS 1
.Ft "void"
.Fn AG_RegisterClass "AG_ObjectClass *ops"
.Pp
.Ft "void"
.Fn AG_UnregisterClass "AG_ObjectClass *ops"
.Pp
.Ft "AG_ObjectClass *"
.Fn AG_FindClass "const char *name"
.Pp
.Ft "int"
.Fn AG_ObjectIsClass "AG_Object *obj" "const char *class_pattern"
.Pp
.Ft "AG_ObjectClass *"
.Fn AG_ObjectSuperclass "AG_Object *obj"
.Pp
.Fn AGOBJECT_FOREACH_CLASS "AG_Object *child_obj" "AG_Object *parent_obj" "TYPE type" "const char *class_pattern"
.Pp
.nr nS 0
The
.Fn AG_RegisterClass
function is used to register a new object class (described by
.Fa ops )
in the object class table.
This table contains, notably, all the information needed by
.Fn AG_ObjectLoad
to load previously saved objects from disk or network and completely
recreate them in memory.
.Pp
.Fn AG_UnregisterClass
removes the specified entry from the object class table.
.Pp
The
.Fn AG_FindClass
function queries the object type table for the given class
.Fa name
and returns a pointer to the object's class information structure.
.Pp
The
.Fn AG_ObjectIsClass
function returns 1 if the given object's class name matches the given
.Fa class_pattern ,
which may contain wildcards such as
.Dq MyClass:*
or
.Dq MyClass:*:MySubclass:* .
.Pp
The
.Fn AG_ObjectSuperclass
function returns a pointer to the
.Fa AG_ObjectClass
structure describing the superclass of the given object (or if the object is
an instance of the base class, the base class is returned).
.Pp
.Fn AGOBJECT_FOREACH_CLASS
is a macro that iterates
.Fa child_obj
(cast to given
.Fa type )
over every child object of
.Fa parent_obj
with a class matching
.Fa class_pattern .
Example:
.Bd -literal
struct my_class *my_obj;

AGOBJECT_FOREACH_CLASS(my_obj, parent_obj, my_class, "MyClass") {
	printf("Object %s is an instance of MyClass\\n",
	    AGOBJECT(my_obj)->name);
}
.Ed
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn AG_ObjectInUse "AG_Object *obj"
.Pp
.Ft "AG_ObjectDep *"
.Fn AG_ObjectAddDep "AG_Object *obj" "AG_Object *depobj"
.Pp
.Ft "void"
.Fn AG_ObjectDelDep "AG_Object *obj" "AG_Object *depobj"
.Pp
.Ft "Uint32"
.Fn AG_ObjectEncodeName "AG_Object *obj" "AG_Object *depobj"
.Pp
.Ft "int"
.Fn AG_ObjectFindDep "AG_Object *obj" "Uint32 ind" "AG_Object **objp"
.Pp
.nr nS 0
.Fn AG_ObjectInUse
returns 1 if the given object is being referenced by another object instance
or 0 if it isn't.
.Pp
.Fn AG_ObjectAddDep
either creates a new dependency upon
.Fa depobj
or increments the reference count if one exists.
.Fn AG_ObjectDelDep
decrements the reference count upon
.Fa depobj
and removes the dependency if the count reaches zero (unless the object has the
.Dv AG_OBJECT_PRESERVE_DEPS
flag set).
.Pp
.Fn AG_ObjectEncodeName
returns a 32-bit integer identifier for the dependency, suitable for writing
into data files.
It may return the special values 0 (NULL reference) and 1 (self-reference),
the meaning of which is object-specific.
.Pp
.Fn AG_ObjectFindDep
tries to resolve the given 32-bit dependency identifier, return 0 on success
and -1 on failure.
.Sh RELEASING RESOURCES
.nr nS 1
.Ft "void"
.Fn AG_ObjectDestroy "AG_Object *obj"
.Pp
.Ft void
.Fn AG_ObjectFreeDataset "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeEvents "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeProps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeDeps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeDummyDeps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeChildren "AG_Object *obj"
.Pp
.nr nS 0
The
.Fn AG_ObjectFreeDataset
function frees any dynamically allocated resources by invoking the
.Fn reinit
of every class in the inheritance hierachy.
The function also clears the
.Dv AG_OBJECT_RESIDENT
flag.
Contrary to the
.Fn destroy
operation,
.Fn reinit
must leave the data structures in a consistent state (e.g., for a subsequent
.Fn load
operation).
.Pp
The
.Fn AG_ObjectDestroy
function frees all resources reserved by the given object (and any of its
children that is not being referenced).
.Fn AG_ObjectDestroy
invokes the
.Fn reinit
and
.Fn destroy
operations of every class in the inheritance hierarchy.
Note that
.Fn AG_ObjectDestroy
also cancels any
.Xr AG_Timeout 3
event scheduled for future execution.
Unless the
.Dv AG_OBJECT_STATIC
flag is set,
.Fn AG_ObjectDestroy
invokes
.Xr free 3
on the structure.
.Pp
Internally,
.Fn AG_ObjectDestroy
invokes
.Fn AG_ObjectFreeEvents ,
.Fn AG_ObjectFreeProps ,
.Fn AG_ObjectFreeDeps
and
.Fn AG_ObjectFreeChildren ,
but these functions may be called directly in order to destroy and reinitialize
the event handler list, the property table and destroy the child objects,
respectively.
.Pp
In addition to reinitializing the event handler table,
.Fn AG_ObjectFreeEvents
also cancels scheduled events.
.Pp
.Fn AG_ObjectFreeChildren
releases all resources allocated by child objects, under the specified parent
object.
The function assumes that none of the child objects are currently in use.
.Pp
.Fn AG_ObjectFreeDummyDeps
removes entries in the dependency table where the reference count is zero
(which occur in objects that have the
.Dv AG_OBJECT_PRESERVE_DEPS
flag set).
.Pp
.Sh ARCHIVING
.nr nS 1
.Ft "int"
.Fn AG_ObjectLoad "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectLoadFromFile "AG_Object *obj" "const char *file"
.Pp
.Ft "int"
.Fn AG_ObjectLoadData "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectLoadDataFromFile "AG_Object *obj" "const char *file"
.Pp
.Ft "int"
.Fn AG_ObjectLoadGeneric "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectLoadGenericFromFile "AG_Object *obj" "const char *file"
.Pp
.Ft "int"
.Fn AG_ObjectSave "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSaveAll "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSaveToFile "AG_Object *obj" "const char *path"
.Pp
.Ft "int"
.Fn AG_ObjectSerialize "AG_Object *obj" "AG_DataSource *ds"
.Pp
.Ft "int"
.Fn AG_ObjectUnserialize "AG_Object *obj" "AG_DataSource *ds"
.Pp
.Ft "int"
.Fn AG_ObjectPageIn "AG_Object *obj"
.Pp
.Ft "int"
.Fn AG_ObjectPageOut "AG_Object *obj"
.Pp
.nr nS 0
These functions implement archiving (or "serialization") of generic object
information and arbitrary datasets to an efficient, machine-independent
representation.
.Pp
The
.Fn AG_ObjectLoad
function (and its variants) are used to load the generic part or the dataset
of either a single object or an object hierarchy, from archived data.
.Fn AG_ObjectLoad
invokes the
.Fn load
operation of every class in the inheritance hierarchy of the object.
.Pp
.Fn AG_ObjectLoad ,
.Fn AG_ObjectLoadGeneric
and
.Fn AG_ObjectLoadData
look for the archive file in the default search path (using the
.Sq load-path
setting of
.Xr AG_Config 3 ) .
.Pp
.Fn AG_ObjectLoadFromFile ,
.Fn AG_ObjectLoadGenericFromFile
and
.Fn AG_ObjectLoadDataFromFile
will load the data from a specific file.
.Pp
Note that when loading object hierarchies, objects will need to be allocated
and initialized from scratch.
This functionality requires that all classes be registered with
.Fn AG_RegisterClass .
.Pp
The
.Fn AG_ObjectSave
function creates an archive of the given object in the default location
(i.e., the
.Sq save-path
setting of
.Xr AG_Config 3 ) .
.Fn AG_ObjectSave
invokes the
.Fn load
operation of every class in the inheritance hierarchy of the object.
The
.Fn AG_ObjectSaveAll
variant also saves the entire tree of child objects.
.Pp
.Fn AG_ObjectSaveToFile
archives the given object to the specified file.
.Pp
.Fn AG_ObjectSerialize
writes an archive of the given object to the specified
.Xr AG_DataSource 3 ,
and
.Fn AG_ObjectUnserialize
reads an archive of the given object.
Note that the
.Dv AG_OBJECT_CHLD_AUTOSAVE
feature will not work with these functions.
.Pp
The
.Fn AG_ObjectPageIn
function loads an object's dataset into memory, assuming it is a persistent
object and its dataset can be found on storage.
On success, the
.Dv AG_OBJECT_RESIDENT
flag is set.
.Fn AG_ObjectPageOut
checks whether an object is referenced by another object and if that is
not the case, the dataset is archived to storage and freed from memory.
Both functions return 0 on success or -1 if an error occured.
.Sh EVENTS
The
.Nm
mechanism generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void"
The object has been attached to another.
This event originates from the parent object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void"
The object has been detached from its parent.
The linkage lock is held during the execution of the event handler.
This event originates from the parent.
.It Fn child-attached "void"
Same as
.Fn attached ,
except that the event is sent from the child to the parent.
.It Fn child-detached "void"
Same as
.Fn detached ,
except that the event is sent from the child to the parent.
.It Fn moved "AG_Object *new_parent"
The object has been moved from its current parent to
.Fa new_parent .
The linkage lock is held during the execution of the event handler.
This event originates from the previous parent.
.It Fn renamed "void"
The object's name has changed.
.It Fn prop-added "AG_Prop *prop"
A new
.Xr AG_Prop 3
property has been added.
.It Fn prop-modified "AG_Prop *prop"
The value of the given property has been modified.
.It Fn object-post-load-generic "const char *path"
Invoked if
.Fn AG_ObjectLoadGeneric
succeeds.
If the object was loaded from file,
.Fa path
is the pathname of the file.
.It Fn object-post-load-data "const char *path"
Invoked by
.Fn AG_ObjectLoadData ,
on success.
If the object was loaded from file,
.Fa path
is the pathname of the file.
.El
.Sh EXAMPLES
See
.Pa demos/objsystem
in the Agar source distribution.
.Sh SEE ALSO
.Xr AG_Intro 3 ,
.Xr AG_Event 3 ,
.Xr AG_Prop 3 ,
.Xr AG_Timeout 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
