.\"	$Csoft: object.3,v 1.82 2005/09/27 00:25:16 vedge Exp $
.\"
.\" Copyright (c) 2001-2007 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt AG_OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Object
.Nd agar object system
.Sh SYNOPSIS
.Bd -literal
#include <agar/core.h>
.Ed
.Sh DESCRIPTION
The Agar object system is implemented around the
.Nm
structure.
The system handles memory management, persistence and interdependencies
between a set of objects organized in a tree which is organized like a
virtual file system.
.Pp
The
.Nm
interface is also responsible for managing events (see
.Xr AG_Event 3 ) ,
timers (see
.Xr AG_Timeout 3 )
and generic properties (see
.Xr AG_Prop 3 ) .
.Sh INITIALIZATION AND LINKAGE
.nr nS 1
.Pp
.Ft "AG_Object *"
.Fn AG_ObjectNew "void *parent" "const char *name"
.Pp
.Ft "void"
.Fn AG_ObjectInit "void *obj" "const char *name" "const void *ops"
.Pp
.Ft "void"
.Fn AG_ObjectAttach "void *new_parent" "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectAttachPath "const char *parent_path" "void *child"
.Pp
.Ft "void"
.Fn AG_ObjectDetach "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectMove "void *obj" "void *new_parent"
.Pp
.Ft "void *"
.Fn AG_ObjectRoot "const void *obj"
.Pp
.Ft "void *"
.Fn AG_ObjectFindParent "const void *obj" "const char *name" "const char *type"
.Pp
.Ft "int"
.Fn AG_ObjectCopyName "const void *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn AG_LockLinkage "void"
.Pp
.Ft "void"
.Fn AG_UnlockLinkage "void"
.Pp
.Ft "void"
.Fn AG_ObjectSetName "void *obj" "const char *new_name"
.Pp
.Ft "void"
.Fn AG_ObjectSetOps "void *obj" "const void *ops"
.Pp
.nr nS 0
The
.Fn AG_ObjectNew
function allocates and initializes a new, generic AG_Object and attaches it to
.Fa parent
if not NULL.
.Pp
The
.Fn AG_ObjectInit
function initializes an AG_Object structure.
The
.Fa name
string identifies this object instance.
It will be truncated if it exceeds
.Dv AG_OBJECT_NAME_MAX
bytes in length, and any
.Sq /
characters are replaced by
.Sq _ .
If
.Fa ops
is not NULL, it should point to the
.Ft AG_ObjectOps
structure, which contains class-specific information:
.Pp
.Bd -literal
typedef struct ag_object_ops {
	const char *name;                          /* Class name */
	size_t size;                               /* Size of structure */
	AG_Version ver;                            /* Version numbers */

	void (*init)(void *obj, const char *name); /* Initialize */
	void (*reinit)(void *obj);                 /* Free data */
	void (*destroy)(void *obj);                /* Release */
	int  (*load)(void *obj, AG_Netbuf *buf);   /* Load data */
	int  (*save)(void *obj, AG_Netbuf *buf);   /* Save data */
	void *(*edit)(void *obj);                  /* Edit data */
} AG_ObjectOps;
.Ed
.Pp
The
.Va name
member is the name of this class, where subclasses are separated by a
colon, such as
.Sq AG_Superclass:AG_Subclass .
It is implied that the root class is
.Sq AG_Object ,
so there is no need to specify it in the string.
.Pp
The
.Va size
member describes is the amount of memory that will be allocated by the object
system to hold the structure.
.Va ver
contains the version numbers that will be used in data files (see
.Xr AG_Version 3
for more details).
.Pp
The
.Fn init
operation initializes an
.Nm
instance after memory has been allocated for it.
A subclass object's
.Fn init
should invoke the
.Fn init
function of its superclass.
For direct subclasses of
.Fn AG_Object ,
this function is
.Fn AG_ObjectInit .
.Pp
The
.Fn reinit
operation releases any data that was dynamically allocated by the object.
.Fn reinit
is invoked by the object system:
.Pp
.Bl -bullet -compact
.It
Prior to a
.Fn load ,
to avoid having to free data from the loader.
.It
Subsequent to a
.Dv PAGE_OUT ,
to free data no longer being referenced.
.It
Prior to a
.Fn destroy
operation where the object is being freed.
.El
.Pp
The
.Fn destroy
operation is invoked from
.Fn AG_ObjectDestroy
to release any resources that are not handled by
.Fn reinit .
Note that
.Fn destroy
must not free the
.Nm
structure itself.
.Pp
The
.Fn load
and
.Fn save
operations are responsible for archiving any persistent
.Nm
data (see the
.Em ARCHIVING AND PAGING
section for more information).
.Pp
If the compile-time option
.Dv EDITION
is defined, the
.Fn edit
operation create the main user interface window for editing the object data.
.Pp
If other windows are to be created as part of this instance's edition process,
they should be attached to the main edition window using
.Xr AG_WindowAttach 3 .
The
.Fn edit
operation can also return other types of widgets, such as a
.Xr AG_Box 3
container.
.Pp
The following public
.Nm
flags are defined:
.Pp
.Bd -literal
#define AG_OBJECT_RELOAD_PROPS   0x001 /* Don't free props before load */
#define AG_OBJECT_NON_PERSISTENT 0x002 /* Data is not archivable */
#define AG_OBJECT_INDESTRUCTIBLE 0x004 /* Not destructible (advisory) */
#define AG_OBJECT_DATA_RESIDENT  0x008 /* Data is in memory (RO) */
#define AG_OBJECT_PRESERVE_DEPS  0x010 /* Don't remove dep if count=0 */
#define AG_OBJECT_STATIC         0x020 /* Don't free() after detach */
#define AG_OBJECT_READONLY       0x040 /* Disallow edition (advisory) */
#define AG_OBJECT_REOPEN_ONLOAD  0x200 /* Recreate editor UI on load */
#define AG_OBJECT_REMAIN_DATA    0x400 /* Keep data resident */
.Ed
.Pp
The
.Dv AG_OBJECT_RELOAD_PROPS
flag prevents the
.Xr AG_Prop 3
table from being cleared by
.Fn AG_ObjectLoad .
.Pp
.Dv AG_OBJECT_NON_PERSISTENT
prevents this object (and its children) from being archived by
.Fn AG_ObjectSave .
If set,
.Fn AG_ObjectPageIn
and
.Fn AG_ObjectPageOut
become no-ops.
.Pp
The
.Dv AG_OBJECT_INDESTRUCTIBLE
flag is purely advisory and disallows the user from destroying the
object via
.Xr AG_ObjectMgr 3 .
.Pp
.Dv AG_OBJECT_READONLY
is also advisory and disallows object-specific
.Va edit
operations from modifying object data.
.Pp
The
.Dv AG_OBJECT_REOPEN_ONLOAD
flag arranges for the graphical interface (as returned by the object's
.Sq edit
operation) to be automatically destroyed and recreated upon
.Fn AG_ObjectLoad .
This flag is useful for complex objects where the graphical interface
references dynamically allocated object data.
.Pp
The read-only
.Dv AG_OBJECT_DATA_RESIDENT
flag is set by the object system to indicate that this object's data is
resident in memory.
.Pp
Objects are organized in a tree structure.
.Fn AG_ObjectAttach
attaches an object to a new parent and
.Fn AG_ObjectDetach
detaches an object from its current parent.
These operations raise
.Sq attached
and
.Sq detached
events.
Prior to detaching the object,
.Fn AG_ObjectDetach
cancels scheduled
.Xr AG_Timeout 3
events (unless they have the special
.Dv AG_TIMEOUT_DETACHABLE
flag set).
If
.Fa parent
is NULL,
.Fn AG_ObjectAttach
is a no-op.
.Pp
.Fn AG_ObjectAttachPath
is a variant of
.Fn AG_ObjectAttach
which looks up the parent using
.Fa parent_path .
.Pp
.Fn AG_ObjectMove
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
Unlike
.Fn AG_ObjectDetach ,
.Fn AG_ObjectMove
does not cancel scheduled timeout events.
.Pp
The
.Fn AG_ObjectRoot
function traverses the given object's ancestry and return a pointer to the root
item.
.Fn AG_ObjectFindParent
traverse the ancestry until a parent item matches the non-NULL
.Fa name
and
.Fa type
arguments.
The global object linkage must remain locked throughout the execution of both
.Fn AG_ObjectRoot
and
.Fn AG_ObjectFindParent .
.Pp
The
.Fn AG_ObjectCopyName
function copies the absolute pathname of an object instance to a fixed-size
buffer, returning 0 on success and -1 on failure.
.Pp
Since
.Fn AG_ObjectCopyName
must perform an inverse traversal of the tree, and an object instance may
move from one parent to another, there is a global lock protecting the object
linkage.
.Fn AG_LockLinkage
and
.Fn AG_UnlockLinkage
are used to acquire or release this lock (no-ops unless Agar is compiled with
thread safety).
.Pp
.Fn AG_ObjectSetName
changes the name of the given object.
.Fn AG_ObjectSetOps
changes the generic operation vector (pointer to
.Ft AG_ObjectOps
structure) associated with the given object.
.Sh CLASS INFORMATION
.nr nS 1
.Ft "void"
.Fn AG_RegisterType "const AG_ObjectOps *ops" "int icon"
.Pp
.Ft "AG_ObjectType *"
.Fn AG_FindType "const char *name"
.Pp
.Ft "int"
.Fn AG_ObjectIsClass "void *obj" "const char *class_pattern"
.Pp
.Fn AGOBJECT_FOREACH_CLASS "void *child_obj" "void *parent_obj" "TYPE type" "const char *class_pattern"
.Pp
.Ft "SDL_Surface *"
.Fn AG_ObjectIcon "void *p"
.Pp
.nr nS 0
The
.Fn AG_RegisterType
function is used to register a new object class (described by
.Fa ops )
with the object type table.
This table contains all the information needed by
.Fn AG_ObjectLoad
to load previously saved objects from disk or network and completely
recreate them in memory.
The
.Fa icon
argument is an
.Xr AG_IconMgr 3
icon name (for example,
.Dv OBJ_ICON )
used by
.Xr AG_ObjMgr 3 .
.Pp
The
.Fn AG_FindType
function queries the object type table for the given class
.Fa name
and returns a pointer to the following structure (or NULL on failure):
.Bd -literal
typedef struct ag_object_type {
	const AG_ObjectOps *ops;
	int icon;
} AG_ObjectType;
.Ed
.Pp
The
.Fn AG_ObjectIsClass
function returns 1 if the given object's class name matches the given
.Fa class_pattern ,
which may contain wildcards such as
.Sq MyClass:*
or
.Sq MyClass:*:MySubclass:* .
.Pp
.Fn AGOBJECT_FOREACH_CLASS
is a convenience macro that iterates
.Fa child_obj
(cast to given
.Fa type )
over every child object of
.Fa parent_obj
with a class matching
.Fa class_pattern .
Example:
.Bd -literal
struct my_class *my_obj;

AGOBJECT_FOREACH_CLASS(my_obj, parent_obj, my_class, "MyClass") {
	printf("Object %s is an instance of MyClass\\n",
	    AGOBJECT(my_obj)->name);
}
.Ed
.Pp
.Fn AG_ObjectIcon
returns a surface for the icon associated with the given class.
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn AG_ObjectInUse "const void *obj"
.Pp
.Ft "AG_ObjectDep *"
.Fn AG_ObjectAddDep "void *obj" "void *depobj"
.Pp
.Ft "void"
.Fn AG_ObjectDelDep "void *obj" "void *depobj"
.Pp
.Ft "Uint32"
.Fn AG_ObjectEncodeName "const void *obj" "const void *depobj"
.Pp
.Ft "int"
.Fn AG_ObjectFindDep "const void *obj" "Uint32 ind" "AG_Object **objp"
.Pp
.nr nS 0
.Fn AG_ObjectInUse
returns 1 if the given object is being referenced by another object instance
or 0 if it isn't.
.Pp
.Fn AG_ObjectAddDep
either creates a new dependency upon
.Fa depobj
or increments the reference count if one exists.
.Fn AG_ObjectDelDep
decrements the reference count upon
.Fa depobj
and removes the dependency if the count reaches 0 (unless the object has the
.Dv AG_OBJECT_PRESERVE_DEPS
flag set).
.Pp
.Fn AG_ObjectEncodeName
returns a 32-bit integer identifier for the dependency, suitable for writing
into data files.
It may return the special values 0 (NULL reference) and 1 (self-reference),
the meaning of which is object-specific.
.Pp
.Fn AG_ObjectFindDep
tries to resolve the given 32-bit dependency identifier, return 0 on success
and -1 on failure.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "void"
.Fn AG_ObjectDestroy "void *obj"
.Pp
.Ft void
.Fn AG_ObjectFreeData "void *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeEvents "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeProps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeDeps "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeChildren "AG_Object *obj"
.Pp
.Ft "void"
.Fn AG_ObjectFreeZerodeps "AG_Object *obj"
.Pp
.nr nS 0
The
.Fn AG_ObjectDestroy
function is called to free all resources reserved by the given object instance,
including its children (assuming that they are not currently in use).
.Fn AG_ObjectDestroy
also cancels any
.Xr AG_Timeout 3
event scheduled for future execution.
To permit static allocation,
.Fn AG_ObjectDestroy
does not invoke
.Xr free 3
on the AG_Object structure.
.Pp
Internally,
.Fn AG_ObjectDestroy
invokes
.Fn AG_ObjectFreeEvents ,
.Fn AG_ObjectFreeProps ,
.Fn AG_ObjectFreeDeps
and
.Fn AG_ObjectFreeChildren ,
but these functions may be called directly in order to destroy and reinitialize
the event handler list, the property table and the child instances,
respectively.
.Pp
In addition to reinitializing the event handler table,
.Fn AG_ObjectFreeEvents
also cancels scheduled events.
.Pp
.Fn AG_ObjectFreeChildren
invokes
.Xr free 3
on an object's children (except those with the
.Dv AG_OBJECT_STATIC
flag set), assuming that none of them are in use.
.Pp
The
.Fn AG_ObjectFreeData
function invokes the
.Va reinit
operation of
.Fa obj
(if there is one) in order to free dynamic data, and clears the
.Dv AG_OBJECT_DATA_RESIDENT
flag.
.Pp
The
.Fn AG_ObjectFreeZerodeps
function is used in situations where it is necessary to remove dependencies
that have a reference count of zero for the given object (and its children).
Dependencies with a reference count of zero only occur in objects that have the
.Dv AG_OBJECT_PRESERVE_DEPS
flag set.
.Sh ARCHIVING AND PAGING
.nr nS 1
.Ft "int"
.Fn AG_ObjectLoad "void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSave "const void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectSaveAll "const void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectPageIn "void *obj"
.Pp
.Ft "int"
.Fn AG_ObjectPageOut "void *obj"
.Pp
.nr nS 0
These functions implement archiving of objects (also known as
"serialization" or "flattening" in object-oriented terminology).
Persistent information such as size, dependencies and position in the
hierarchy are encoded in a machine-independent format.
.Pp
The
.Fn load
and
.Fn save
functions of the generic operation vector are responsible for
archiving of data specific to the type of object at hand.
Except for direct subclasses of
.Nm ,
the
.Fn load
and
.Fn save
operations of a given class should explicitely invoke the
.Fn load
and
.Fn save
operations of its superclass.
.Pp
The
.Fn AG_ObjectLoad
function loads the state of an object instance and its descendants from
an archive.
The first file found in the search path (the colon-separated
.Sq load-path
config setting) is used.
.Fn AG_ObjectLoad
performs the following operations, in order:
.Bl -enum
.It
Cancel scheduled
.Xr AG_Timeout 3
events (that don't have the
.Dv AG_TIMEOUT_LOADABLE
flag set).
.It
Load the generic part (the
.Nm
class) of
.Fa obj
and its descendants.
Archived siblings found in the data file are each compared against the
currently attached object instances.
If a match is found, the
.Va reinit
op is called.
If there is no resident instance matching an archived object, one is
dynamically allocated and initialized using the type switch (the
.Va agTypes[]
array).
If a resident instance has no archived counterpart, it is destroyed (as
long as it is not currently in use).
.It
Resolve the dependencies of
.Fa obj
and its children, so encoded object references may be decoded in the
following step.
.It
If the object or any of its children has resident dynamic data, it is
reloaded.
.El
.Pp
The
.Fn AG_ObjectSave
function creates an archive of the given AG_Object in the save
directory (the
.Sq save-path
config setting).
The
.Fn AG_ObjectSaveAll
variant also saves child objects.
.Pp
The
.Fn AG_ObjectPageIn
function loads an object's data into memory (assuming it is a persistent
object and can be found in storage) and marks the object resident.
.Fn AG_ObjectPageOut
checks whether an object is referenced by another object and if that is
not the case, the object's data is saved to storage and freed from memory.
Both functions return 0 on success or -1 if an error occured.
.Sh EVENTS
The
.Nm
mechanism generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void"
The object has been attached to another.
This event originates from the parent object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void"
The object has been detached from its parent.
The linkage lock is held during the execution of the event handler.
This event originates from the parent.
.It Fn child-attached "void"
Same as
.Fn attached ,
except that the event is sent from the child to the parent.
.It Fn child-detached "void"
Same as
.Fn detached ,
except that the event is sent from the child to the parent.
.It Fn moved "void *new_parent"
The object has been moved from its current parent to
.Fa new_parent .
The linkage lock is held during the execution of the event handler.
This event originates from the previous parent.
.It Fn renamed "void"
The object's name has changed.
.It Fn prop-added "AG_Prop *prop"
A new
.Xr AG_Prop 3
property has been added.
.It Fn prop-modified "AG_Prop *prop"
The value of the given property has been modified.
.El
.Sh SEE ALSO
.Xr AG_Intro 3 ,
.Xr AG_Event 3 ,
.Xr AG_Prop 3 ,
.Xr AG_Timeout 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
