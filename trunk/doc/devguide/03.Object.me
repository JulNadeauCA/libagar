.\"	$Csoft: 03.Object.me,v 1.5 2004/03/02 08:53:24 vedge Exp $
.\"
.\" Copyright (c) 2003, 2004 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.c1 "The Object System"
.lp
The logic of Agar applications is built around a tree of persistent 
\fBobjects\fP.
In a game scenario, these objects will be created by a level designer,
and will typically include maps, characters, monsters and \fIdoodads\fP.
Agar handles memory management, persistance and dependency issues for such
objects, in a generic manner.
.lp
The programmer is free to implement new types of objects and derive objects
from others.
Throughout the Agar documentation, the term \fIobject\fP or \fIgeneric object\fP
refers to the \fBstruct object\fP part of derived objects, and the term
\fIdata\fP or \fIobject data\fP refers to the rest of the structure.
The generic part of objects is always resident, but the object data may be
moved dynamically between mass storage and memory.
.\"
.\".c2 "Built-in object types"
.\".sp
.\".Bd -fig "Built-in object types"
.\".TS
.\"center allbox tab(:);
.\"c c
.\"l l.
.\"map:2D layered, tile-based maps
.\"perso:Game characters
.\".TE
.\".Ed
.\"
.c2 "The \fBobject\fP structure"
.lp
The members of the \fBobject\fP structure in Fig. X may be referenced
directly.
Except in edition mode, these variables should be considered read-only.
.Bd -fig "Public members of the \fBobject\fP structure"
.TS
center allbox tab(:);
c | c | c | c
l | l | c | l.
Member:Type:Protection:Description
_
\f(CRtype\fP:String:Read-only:T{
This is an identifier which indicates the type of object.
For example, this will be set to "map" for map objects and "perso" for
character objects.
T}
\f(CRname\fP:String:Read-only:T{
This is the object's identifier, unique to the object's parent.
In order to reference a specific object in the world, an absolute reference
as returned by
.Fn object_copy_name ,
must be used.
T}
\f(CRsave_pfx\fP:String:Read-only:T{
This string defines an alternate directory location for the save files
of this object and its children.
T}
\f(CRops\fP:Pointer:Read-only:Generic object operation vector (see Fig. X).
\f(CRflags\fP:Integer:Read-only:Generic object flags (see Fig. X).
\f(CRlock\fP:Mutex:-:T{
Protects read-write members (if
.Dv THREADS
is set).
T}
\f(CRpos\fP:Pointer:T{
.ce
Read-write
.br
.ce
.ps 8
(protected by \f(CRlock\fP)
T}:T{
This variable points to a \fBposition\fP structure if the object holds
a unique position on a map.
If that is not the case, it is set to
.Dv NULL .
T}
.TE
.Ed
.sp
.Bd -fig "Generic \fBobject\fP flags"
.TS
center allbox tab(:);
c cw(3.8i)
l lw(3.8i).
Flag:Description
_
\f(CROBJECT_RELOAD_PROPS\fP:T{
If this flag is set, the table of generic properties is not cleared prior to
a load operation.
T}
\f(CROBJECT_NON_PERSISTENT\fP:T{
This flag inhibits load and save operations on the object and its children.
T}
\f(CROBJECT_INDESTRUCTIBLE\fP:T{
This is an advisory flag that indicates that this object should not be
destroyed.
It is used notably by the level editor to prevent destruction of system
objects (such as the \fBmap-editor\fP pseudo-object which is used only for
dependency tracking in edition mode).
T}
\f(CROBJECT_DATA_RESIDENT\fP:T{
This is a non-persistent flag which indicates that the object data is
currently resident.
T}
\f(CROBJECT_PRESERVE_DEPS\fP:T{
This flag inhibits the deletion of entries in this object's dependency table
whose reference count has reached 0.
T}
\f(CROBJECT_STATIC\fP:T{
If this flag is set,
.Xr free 3
is not invoked after this object has been detached and freed.
This allows objects to be statically allocated.
T}
\f(CROBJECT_READONLY\fP:T{
This is an advisory flag to indicate that this object should not be edited
or modified in any way.
T}
.TE
.Ed
.c2 "Persistance"
.lp
One of the primary design goals of Agar is the ability to maintain a large,
persistent world.
The object system provides interfaces for saving the state of objects in
machine-independent format.
Implementations of persistent objects provide pointers to \fBload\fP and
\fBsave\fP functions, which typically use Agar's I/O library to read and
write primitive data types.
Agar also provides signature and versioning facilities.
.c3 "The object load algorithm"
.lp
The
.Fn object_load
function is called to restore the state of a previously saved object and its
children, recursively.
.pp
Firstly, this function frees the object data, if it is resident, and reads the
generic part of the object from the save.
Note that the entries of the dependency table are not yet resolved at this
point, since the whole object tree must be restored before the dependencies are
resolved.
.pp
Second, the generic property table of the object is read.
Unless the
.Dv OBJECT_RELOAD_PROPS
flag is set, the table is cleared beforehand.
.pp
If the save includes a unique object position (see Chapter X), it is decoded
but the object is not positioned until the object tree has been completely
restored, since the maps must be in a consistent state before the projections
are made.
.pp
The next step is to decode the media references (ie. graphics and audio).
If there is media currently being referenced, these references are resolved
immediately.
Otherwise, they will be resolved only when they are requested.
.pp
The state of the object's children (their generic part) is then restored.
If the save file contains child objects which do not match with an existing
object, they are allocated from scratch using the type switch
(see section 3.3.2).
Existing objects which do not have a match in the save file are destroyed
(as long as they are not currently referenced).
.pp
Finally, the object's dependency table is resolved and the data of the object
(if it is resident), and those of its children which are resident is restored.
.\"
.c3 "The Type Switch"
.lp
When creating an object, Agar allocates enough space for the generic
\fBobject\fP structure, as well as object derivate data, depending on the
type of object.
Exactly how much space is needed for a given type of object is defined by
a table referred to as the \fBtype switch\fP.
This information is particularly useful when allocating space for objects that
have been previously saved but do not currently exist.
.lp
Objects implemented as part of the base Agar engine are registered in the
.Va typesw[]
array.
Applications can register object types dynamically using the
.Fn typesw_register
function.
.c2 "Memory management"
.lp
Agar is able to accomodate complex applications such as a role-playing game
with hundreds of maps, using limited resources.
This is done using a dynamic paging algorithm, where the data is stored to disk
(or network) when it is not needed, and loaded back into memory, on demand.
.lp
In addition, data (typically graphics, 3D models and sounds) may be shared
between objects, while Agar keeps reference counts for purposes of garbage
collection.
.lp
Figure X illustrates a game scenario, where two maps are currently visible,
Cave L1 and Cave L2.
Both these maps are sharing the same set of graphics and audio samples.
The third map is not visible so its nodes are saved to disk and freed.
.\"
.Bd -fig "Sharing of data between objects"
.PS
Cave1: circle "\fBCave L1\fP" "Visible" "Nodes/data" "(resident)" rad 0.45
Cave2: circle "\fBCave L2\fP" "Visible" "Nodes/data" "(resident)" rad 0.45 at Cave1 - (0,0.9)
Cave3: circle "\fBCave L3\fP" "Not visible" "Nodes/data" "(paged out)" rad 0.45 at Cave2 - (0,0.9)
CaveAudio: box "\fBCave audio\fP" "2 refs" at Cave2 + (-1,0)
CaveTiles: box "\fBCave tiles\fP" "3 refs" at Cave2 + (1,0)
arrow from Cave1.w to CaveAudio.ne
arrow from Cave1.e to CaveTiles.nw
arrow from Cave2.e to CaveTiles.w
arrow from Cave3.w to CaveAudio.se
arrow from Cave3.e to CaveTiles.sw
line from Cave1.w to Cave1.e
line from Cave2.w to Cave2.e
line from Cave3.w to Cave3.e
.PE
.Ed
.c2 "Dependencies"
.lp
The garbage collection process requires a way to tell whether an object
is currently in use.
To achieve this, the \fBobject\fP structure includes a dependency table,
indicating the other objects this object depends upon.
This way, it is possible to tell whether an given object is in use by traversing
the object tree and searching for references to it.
.\"
.c2 "Generic events"
.lp
The object structure includes a table to associate specific event handler
functions to specific types of events, which are identified by strings.
.lp
The event system is used extensively by the widget system to deliver keyboard
and mouse events, but it is also useful in games.
.\"
.c2 "Generic properties"
.lp
The \fBobject\fP structure also includes a table of generic properties, which
are simple key=value pairs, where the value may be one of many primitive
types (notably integer, floating-point, string, pointer and boolean values).
This facility is helpful in situations where the level designers have to
store miscellaneous data along with different objects.
.\"
.c2 "Positionment"
.lp
Many game-related objects (characters, for once) occupy a unique position in
the world.
To accomodate this, the \fBobject\fP structure includes optional position
information, such as the \fBmap\fP coordinates, orientation and associated
input device, if any.
.\"
.c2 "A sample object implementation"
.lp
Here is what the implementation of a persistent "door" object may look like.
We want this object to preserve state as to whether the door is open/closed
and locked.
We also generate a unique key, which must be matched in order to open the door,
if it is locked.
Some doors may have to hold inscriptions, so we include a text string for
this purpose.
We don't need sophisticated collision detection, so we use node flags to
indicate whether other objects can move through the door.
.c3 "Data structures"
.lp
We first define a \fBdoor\fP structure, which is derived from the \fBobject\fP
structure.
We also initialize a \fBversion\fP structure, for purposes of data file signing
and versioning.
The \fBobject_ops\fP structure which is passed to
.Fn object_init
indicates object-specific operations.
.Bd -code "The \fBdoor\fP object's data structures"
struct door {
	struct object obj;
	int open, locked, key;
	char *inscription;
};
const struct version door_ver = {
	"agar door",
	0, 0
};
const struct object_ops door_ops = {
	door_init,
	NULL,		/* reinit */
	NULL,		/* destroy */
	door_load,
	door_save,
	door_edit
};
.Ed
.c3 "Initialization"
.lp
The
.Fn object_init
function is invoked to initialize the \fBobject\fP part of the \fBdoor\fP
structure.
The \fBinit\fP operation is responsible for putting the \fBdoor\fP structure
in a consistent state.
A high-quality random 32-bit value is returned by
.Fn arc4random \(dg .
.(f
\(dg As with many other functions, Agar includes a portable version of
.Fn arc4random ,
for operating systems without one.
.)f
We register an event handler function,
.Fn door_open ,
for the "door-open" event, and we initially display the projection map
"Closed".
.lp
An artist could come up with a door pixmap containing three layers:
.(l
\(bu Background and decorations
\(bu Closed door
\(bu Opened door
.l)
.lp
The level designer will then construct a model object with two projection maps
by importing the background on the two, the closed door layer for the
"Closed" map and the opened door layer for the "Open" map.
The level designer then creates copies of the model door, for subsequent
doors in the game.
Of course, the level designer will probably want to use more than one door
model, either using Agar map transformations or different door pixmaps
altogether.
.Bd -code "Initialization of the \fBdoor\fP object"
void
door_init(void *obj, const char *name)
{
	struct door *door = obj;

	object_init(door, "door", name, &door_ops);
	door->open = 0;
	door->locked = 0;
	door->key = (int)arc4random();
	door->inscription = NULL;
	event_new(door, "door-open", door_open, NULL);
	object_set_projmap(door, "Closed");
}
.Ed
.c3 "Load and save routines"
.lp
The object system will invoke the \fBload\fP operation to read the relevant
parts of the door structure from file/network, and the \fBsave\fP operation
to write its contents to machine independent format.
Since \fBload\fP might be used to read data originating from the network,
for instance, it is important to verify the consistency of the data\(dg\(dg.
.(f
\(dg\(dg The \fBread_*\fP functions already perform some consistency checks
of their own.
.)f
.Bd -code "The \fBdoor\fP object's save and load routines"
int
door_load(void *obj, struct netbuf *buf)
{
	struct door *door = obj;

	if (version_read(buf, &door_ver, NULL) != 0)
		return (-1);

	door->open = (int)read_uint8(buf);
	door->locked = (int)read_uint8(buf);
	door->key = (int)read_uint32(buf);
	door->inscription = read_string(buf);

	if (door->open && door->locked) {
		error_set("Inconsistent state");
		return (-1);
	}
	return (0);
}

int
door_save(void *obj, struct netbuf *buf)
{
	struct door *door = obj;

	version_write(buf, &door_ver);
	write_uint8(buf, door->open);
	write_uint8(buf, door->locked);
	write_uint32(buf, (Uint32)door->key);
	write_string(buf, door->inscription);
	return (0);
}
.Ed
.c3 "Event handlers"
.lp
Objects (such as characters) will attempt to open the door by posting it a
"door-open" event using
.Fn event_post
or
.Fn event_forward .
We've already registered an event handler function for "door-open" in
.Fn door_init .
.Bd -code "The \fIdoor-open\fP event handler function"
static void
door_open(int argc, union evarg *argv)
{
	struct door *door = argv[0].p;
	struct object *sender = argv[argc].p;
	int key = argv[1].i;

	if (door->locked) {
		if (key != door->key) {
			event_post(sender, "door-wrong-key", NULL);
			return;
		}
		door->locked = 0;
	}
	door->open = 1;
	object_set_projmap(door, "Open");
}
.Ed
.c3 "Submaps"
.lp
In Agar games, the \fBmap\fP object is used to represent not only levels, but
also the appearance of certain objects inside those levels.
For instance, the appearance of a character will be defined by a set of maps,
which could be named "Moving North", "Moving South", "Idle North",
"Idle South", and so on.
.lp
This method can accomodate very large dynamic objects, and it also allows the
game designer to apply transforms, such as \fBmirror\fP, so that the artist
does not have to come up with separate "Moving West" and "Moving East" sprites,
for instance.
For a pseudo-3D game (such as \fIDiablo\fP\(dg), an object's set of projection
maps could be automatically generated from a 3D model.
.(f
\(dg \fIDiablo\fP is a trademark of Blizzard Entertainment.
.)f
.lp
Since projection maps may include more than one node, node-specific flags
provide a coarse but efficient collision detection method.
Bitmap masks and other techniques are used when more sophisticated collision
detection is required (see chapter X).
.lp
The
.Fn object_set_projmap
function selects among a series of \fBmap\fPs associated with the object,
which one should be laid on top of the level map and repositioned as the
object moves from one node to another.
.lp
As far as our \fBdoor\fP object is concerned, the level designer will have
to create two maps, "Closed" and "Open", and make sure that the relevant tiles
have the \fIwalkable\fP flag in "Open".
