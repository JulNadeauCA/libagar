.\"	$Csoft: object.3,v 1.40 2003/06/21 06:39:44 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object layer
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
The Agar game logic is built upon a tree of
.Nm
structures.
Similar to a filesystem, objects are referenced either by absolute or relative
path names.
.Pp
The
.Nm
layer implements:
.Bl -bullet -compact
.It
Memory management (paging and garbage collection)
.It
Persistence
.It
Linkage
.It
Graphical/audio data management
.It
Position/appearance on maps
.It
Dependencies
.It
Generic events and properties
.El
.Sh INITIALIZATION/LINKAGE
.nr nS 1
.Ft "struct object *"
.Fn object_new "void *parent" "const char *type" "const char *name" \
               "const void *ops"
.Pp
.Ft "void"
.Fn object_init "void *obj" "const char *type" "const char *name" \
                "const void *ops"
.Pp
.Ft "void"
.Fn object_attach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_detach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_move "void *oldparent" "void *child" "void *newparent"
.Pp
.Ft "char *"
.Fn object_name "void *obj"
.Pp
.Ft "void"
.Fn lock_linkage "void"
.Pp
.Ft "void"
.Fn unlock_linkage "void"
.Pp
.nr nS 0
The
.Fn object_new
function allocates, initializes and attaches a new, generic object to a parent
(if
.Fa parent
is not NULL).
.Fn object_init
initializes an object.
.Fa name
must not exceed
.Dv OBJECT_NAME_MAX
- 1 in length and
.Fa type
must not exceed
.Dv OBJECT_TYPE_MAX
- 1 in length.
.Pp
If
.Fa ops
is not NULL, it should point to the following structure:
.Bd -literal
struct object_ops {
	void (*init)(void *obj, const char *name);	/* Initialize */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, struct netbuf *buf);	/* Load from buf */
	int  (*save)(void *obj, struct netbuf *buf);	/* Save to buf */
	void (*edit)(void *obj);			/* Edit object */
};
.Ed
.Pp
The
.Fn object_attach
and
.Fn object_detach
functions respectively link and unlink a
.Fa child
object against a
.Fa parent ,
and raises
.Fn attached
and
.Fn detached
events.
.Fn object_move
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
.Pp
The
.Fn object_name
function returns a copy of an object's absolute pathname by doing an inverse
traversal of the object tree, until the root is reached.
.Fn object_name
returns a pointer to a newly allocated, NUL-terminated string containing the
resulting pathname.
Absolute object pathnames cannot be copied to fixed-size buffers, since object
trees may have an arbitrary depth.
.Pp
Since
.Fn object_name
must traverse the tree backwards and the parents may change, a big lock is
required in order to protect linkage.
.Fn lock_linkage
and
.Fn unlock_linkage
acquire and release the linkage lock, respectively.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "void"
.Fn object_destroy "void *obj"
.Pp
.Ft "void"
.Fn object_free_events "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_props "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_childs "struct object *obj"
.Pp
.nr nS 0
The
.Fn object_destroy
function is called to free all resources reserved by
.Fa ob
and its children.
To allow static allocation of
.Nm
structures,
.Fn object_destroy
does not call
.Xr free 3 .
.Pp
.Fn object_destroy
calls
.Fn object_free_events ,
.Fn object_free_props
and
.Fn object_free_childs ,
but these functions may be called directly in order to clear the event handler
list, the property table and the attached objects, respectively.
.Sh PERSISTENCE
.nr nS 1
.Ft "int"
.Fn object_load "void *obj"
.Pp
.Ft "int"
.Fn object_save "void *obj"
.nr nS 0
.Pp
The
.Fn object_load
function loads the state of an object and its descendents from the first file
found in the search path (the colon-separated
.Sq load-path
config setting).
.Fn object_save
saves the state of an object and its descendents to files/directories in the
save directory (the
.Sq save-path
config setting).
.Pp
These functions return 0 on success or -1 if an error occured.
.Sh MAP OPERATIONS
The illusion of objects (such as characters) moving inside a
.Xr map 3
is achieved by maintaining a copy of the object's current submap (a pointer to a
.Xr map 3
structure associated with the object).
Most moving game characters provide submaps called
.Sq [nswe]-idle
and
.Sq [nswe]-move ,
for instance.
The
.Nm
layer is responsible for keeping the submap copy in sync, and adjusting the
motion offsets of its noderefs in response to movement.
.nr nS 1
.Ft "int"
.Fn object_set_submap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_load_submap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_set_position "void *obj" "struct map *map" "int x" "int y" \
                        "int layer"
.Pp
.Ft "void"
.Fn object_unset_position "void *obj"
.Pp
.Ft "void"
.Fn object_control "void *obj" "const char *input_dev"
.Pp
.nr nS 0
The
.Fn object_set_submap
function searches an object's descendents for a map named
.Fa map_name
and selects it as the current submap.
.Fn object_set_submap
returns 0 on success or -1 on failure.
.Fn object_load_submap
initializes and loads a submap called
.Fa map_name .
.Pp
The
.Fn object_set_position
function sets the object's unique position to the given coordinates of
.Fa map .
.Fn object_unset_position
causes an object to vanish from its current position, if there is any.
.Pp
The
.Fn object_control
function assigns the input device named
.Fa input_dev
to the position associated with
.Fa obj .
.Sh DEPENDENCY TABLES
These functions load/save arrays of structures containing each:
.Bl -bullet -compact -enum
.It
An object name string.
.It
An object type string.
.El
.Pp
This allows load/save routines to keep track of an object's dependencies,
as well as to encode object references using indexes.
.Pp
.nr nS 1
.Ft "void"
.Fn object_table_init "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_destroy "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_insert "struct object_table *table" "struct object *obj"
.Pp
.Ft "void"
.Fn object_table_save "struct object_table *table" "struct netbuf *buf"
.Pp
.Ft "int"
.Fn object_table_load "struct object_table *table" "struct netbuf *buf" \
                      "const char *objname"
.Pp
.nr nS 0
The
.Fn object_table_init
function initializes
.Fa table
as a new, empty dependency table.
.Fn object_table_destroy
frees the resources allocated by
.Fa table .
.Pp
The
.Fn object_table_insert
function inserts
.Fa obj
in
.Fa table ,
if it is not already there.
.Pp
The
.Fn object_table_save
function writes
.Fa table
to
.Fa buf .
The
.Fn object_table_load
reads dependencies from
.Fa buf
into
.Fa table ,
and returns 0 on success or -1 if an error occured.
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void *parent"
The object has been attached to a
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void *parent"
The object has been detached from its
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn moved "void *oldparent" "void *newparent"
The object has been moved from
.Fa oldparent
to
.Fa newparent .
The linkage lock is held during the execution of the event handler.
.El
.Sh SEE ALSO
.Xr agar 3 ,
.Xr event 3 ,
.Xr fobj 3 ,
.Xr physics 3 ,
.Xr prop 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
