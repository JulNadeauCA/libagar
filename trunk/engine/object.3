.\"	$Csoft: object.3,v 1.47 2003/08/26 03:37:24 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object layer
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
The Agar game logic is built upon a tree of
.Nm
structures.
The
.Nm
layer is responsible for:
.Pp
.Bl -tag -width "Generic events/props"
.It Memory management
Paging and garbage collection of object data.
.It Persistence
Saving/loading of object data in network format.
.It Linkage/dependencies
Similar to a filesystem, objects may be referenced either by absolute or
relative path names.
Dependency tables keep track of object references to other objects
(sharing the same root).
.It Shared audio/gfx
Objects may reference shared data, such as graphics and audio.
For instance, if the
.Xr map 3
renderer wants to draw a sprite representing a character, the reference is
made using the object's
.Va gfx
pointer.
This
.Va gfx
pointer usually references shared data, but it is possible to use a copy on
write style algorithm to deal with modifications local to object instances.
.It Generic events/props
The
.Nm
object includes a list of event handlers managed by the
.Xr event 3
interface, and a list
of generic properties which are accessed by the
.Xr prop 3
interface.
.El
.Pp
.Sh OBJECT FLAGS
The
.Va flags
member of the
.Nm
structure are defined as:
.Bd -literal
#define OBJECT_RELOAD_PROPS	0x01	/* Don't free props before load */
#define OBJECT_NON_PERSISTENT	0x02	/* Never include in saves */
#define OBJECT_INDESTRUCTIBLE	0x04	/* Not destructible (advisory) */
#define OBJECT_DATA_RESIDENT	0x08	/* Object data is resident */
#define OBJECT_PRESERVE_DEPS	0x10	/* Don't remove a dependency
					   if its reference count is 0. */
#define OBJECT_STATIC		0x20	/* Don't free() after detach. */
#define OBJECT_READONLY		0x40	/* Disallow edition (advisory) */
#define OBJECT_SAVED_FLAGS	(OBJECT_RELOAD_PROPS|OBJECT_INDESTRUCTIBLE)
.Ed
.Pp
The
.Dv OBJECT_RELOAD_PROPS
flag prevents the
.Xr prop 3
table from being cleared as part of a load operation.
.Dv OBJECT_NON_PERSISTENT
prevents the object and its descendents from being saved as part of a save
operation.
If this flag is set,
.Fn object_page_in
and
.Fn object_page_out
are no-ops (but still increment the reference count).
.Pp
The
.Dv OBJECT_INDESTRUCTIBLE
flag advises the object editor not to destroy this object.
.Dv OBJECT_READONLY
advises the object-specific
.Va edit
operation that this object should not be edited.
.Pp
The
.Dv OBJECT_DATA_RESIDENT
flag is set by the
.Nm
system to indicate that the object's data currently resides in memory.
.Sh INITIALIZATION AND LINKAGE
.nr nS 1
.Ft "struct object *"
.Fn object_new "void *parent" "const char *name"
.Pp
.Ft "void"
.Fn object_init "void *obj" "const char *type" "const char *name" \
                "const void *ops"
.Pp
.Ft void
.Fn object_reinit "void *obj" "int free_deps"
.Pp
.Ft "void"
.Fn object_attach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_detach "void *parent" "void *child"
.Pp
.Ft "void"
.Fn object_move "void *oldparent" "void *child" "void *newparent"
.Pp
.Ft "void *"
.Fn object_root "const void *obj"
.Pp
.Ft "int"
.Fn object_copy_name "const void *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn lock_linkage "void"
.Pp
.Ft "void"
.Fn unlock_linkage "void"
.nr nS 0
.Pp
The
.Fn object_new
function allocates and initializes a new, generic object (object derivates
usually provide their own constructor functions).
If
.Fa parent
is not NULL, the object is attached to a parent.
Otherwise, the object is considered to be the root of an object tree.
.Pp
.Fn object_init
initializes an object.
The
.Fa name
and
.Fa type
are truncated if they exceed
.Dv OBJECT_NAME_MAX
and
.Dv OBJECT_TYPE_MAX
in length, respectively.
Instances of
.Sq /
characters in
.Fa name
are replaced by
.Sq _ ,
since slash is the path name separator.
.Pp
If
.Fa ops
is not NULL, it should point to the following structure:
.Bd -literal
struct object_ops {
	void (*init)(void *obj, const char *name);	/* Initialize */
	void (*reinit)(void *obj);			/* Free data */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, struct netbuf *buf);	/* Load data */
	int  (*save)(void *obj, struct netbuf *buf);	/* Save data */
	struct window *(*edit)(void *obj);		/* Edit object */
};
.Ed
.Pp
The
.Fn object_reinit
function invokes the
.Va reinit
operation of
.Fa obj
(if there is one).
The
.Va reinit
operation of
.Xr map 3 ,
for instance, frees the contents of all nodes of the map.
If the
.Fa free_deps
argument is non-zero, the contents of the dependency table are removed
(otherwise all dependencies are expected to have a reference count of either
0 or
.Dv OBJECT_DEP_MAX ) .
.Fn object_reinit
also clears the
.Dv OBJECT_DATA_RESIDENT
flag.
.Pp
The
.Fn object_attach
and
.Fn object_detach
functions respectively link and unlink a
.Fa child
object against a
.Fa parent ,
and raises
.Fn attached
and
.Fn detached
events.
.Fn object_move
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
.Pp
The
.Fn object_root
function traverses the object's ancestry, until the root is reached.
A pointer to the object itself is returned, if the object is the root.
The linkage must remain locked during the execution of
.Fn object_root .
.Pp
The
.Fn object_copy_name
function copies an object's absolute pathname to a fixed-size buffer, and
returns 0 on success and -1 if an error occured, such as the buffer being
too small to hold the full pathname and the terminating NUL.
.Pp
Since
.Fn object_copy_name
must traverse the tree backwards, and an object may move from one parent
to another, the root object provides a lock to protect its linkage.
.Fn lock_linkage
and
.Fn unlock_linkage
acquire and release the world's linkage lock, respectively.
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn object_used "const void *obj"
.Pp
.Ft "struct object_dep *"
.Fn object_add_dep "void *obj" "void *depobj"
.Pp
.Ft "void"
.Fn object_del_dep "void *obj" "void *depobj"
.Pp
.Ft "struct object *"
.Fn object_find_dep "const void *obj" "Uint32 ind"
.Pp
.Ft "Uint32"
.Fn object_dep_index "const void *obj" "const void *depobj"
.nr nS 0
.Pp
The
.Fn object_used
function returns 1 if a given object is referenced from another object
sharing the same root.
.Pp
The
.Fn object_add_dep
function either creates a new dependency upon
.Fa depobj ,
or increment the reference count if one exists.
.Fn object_del_dep
decrements the reference count upon
.Fa depobj ,
removing it if it reaches 0.
.Pp
The
.Fn object_find_dep
function returns the object of the dependency at the given index, for purposes
of decoding object references in network format.
.Fn object_dep_index
returns the index of a dependency, for purposes of encoding object references
in network format.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "int"
.Fn object_destroy "void *obj"
.Pp
.Ft "void"
.Fn object_free_events "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_props "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_childs "struct object *obj"
.nr nS 0
.Pp
The
.Fn object_destroy
function is called to free all resources reserved by
.Fa ob
and its children.
.Fn object_destroy
returns 0 on success or -1 if the given object (or one of its children)
is currently in use.
To permit static allocation,
.Fn object_destroy
does not call
.Xr free 3 .
.Pp
.Fn object_destroy
calls
.Fn object_free_events ,
.Fn object_free_props
and
.Fn object_free_childs ,
but these functions may be called directly in order to clear the event handler
list, the property table and the attached objects, respectively.
.Sh PERSISTENCE
.nr nS 1
.Ft "int"
.Fn object_load "void *obj"
.Pp
.Ft "int"
.Fn object_save "const void *obj"
.Pp
.Ft "int"
.Fn object_page_in "void *obj" "enum object_page_item item"
.Pp
.Ft "int"
.Fn object_page_out "void *obj" "enum object_page_item item"
.nr nS 0
.Pp
The
.Fn object_load
loads the generic part of an object from the first file found in the
search path (the colon-separated
.Sq load-path
config setting).
.Fn object_load
invokes itself on the child objects in a recursive manner.
Note that
.Fn object_load
does not load the object data, unless it is currently resident as result of
a previous
.Fn object_page_in
operation.
.Pp
Saved child objects found in the data file are each compared against the
currently attached objects.
If a match is found, the
.Va reinit
op is called.
The
.Va load
is invoked only if there is currently resident data.
If there is no currently attached object matching a saved object, one is
dynamically allocated and initialized using the type switch (the
.Va typesw[]
array).
If a currently attached object has no matching saved object, it is destroyed
(as long as it is not currently in use).
.Pp
The
.Fn object_save
function writes the state of an object and its descendents to
files/directories in the save directory (the
.Sq save-path
config setting),
in network format.
.Pp
The
.Fn object_page_in
function fetches data associated with an object.
If the data is already resident, its reference count is incremented.
The
.Fa item
argument may be one of:
.Bd -literal
enum object_page_item {
	OBJECT_GFX,		/* Graphics */
	OBJECT_AUDIO,		/* Audio data */
	OBJECT_DATA		/* Object derivate data */
};
.Ed
.Pp
The
.Fn object_page_out
function decrements the reference count on data.
For
.Dv OBJECT_GFX
and
.Dv OBJECT_AUDIO ,
the reference count is decremented on the shared media.
For
.Dv OBJECT_DATA ,
.Fn object_save
and
.Fn object_reinit
are used.
.Pp
These functions return 0 on success or -1 if an error occured.
.Sh MAP OPERATIONS
The illusion of objects (such as characters) moving inside a
.Xr map 3
is achieved by maintaining a copy of the object's current submap (a pointer to a
.Xr map 3
structure associated with the object).
Most moving game characters provide submaps called
.Sq [nswe]-idle
and
.Sq [nswe]-move ,
for instance.
The
.Nm
layer is responsible for keeping the submap copy in sync, and adjusting the
motion offsets of its noderefs in response to movement.
.nr nS 1
.Ft "int"
.Fn object_set_submap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_load_submap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_set_position "void *obj" "struct map *map" "int x" "int y" \
                        "int layer"
.Pp
.Ft "void"
.Fn object_unset_position "void *obj"
.Pp
.Ft "void"
.Fn object_control "void *obj" "const char *input_dev"
.nr nS 0
.Pp
The
.Fn object_set_submap
function searches an object's descendents for a map named
.Fa map_name
and selects it as the current submap.
.Fn object_set_submap
returns 0 on success or -1 on failure.
.Fn object_load_submap
initializes and loads a submap called
.Fa map_name .
.Pp
The
.Fn object_set_position
function sets the object's unique position to the given coordinates of
.Fa map .
.Fn object_unset_position
causes an object to vanish from its current position, if there is any.
.Pp
The
.Fn object_control
function assigns the input device named
.Fa input_dev
to the position associated with
.Fa obj .
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void *parent"
The object has been attached to a
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void *parent"
The object has been detached from its
.Fa parent
object.
The linkage lock is held during the execution of the event handler.
.It Fn moved "void *oldparent" "void *newparent"
The object has been moved from
.Fa oldparent
to
.Fa newparent .
The linkage lock is held during the execution of the event handler.
.El
.Sh TROUBLETONS
If the maximum number of references (0xffffffff-2) is reached, the object
remains resident and the reference count is no longer incremented or
decremented.
The behavior of objects when this occurs requires special attention.
.Pp
Use of interdependencies with the paging system often increases debugging
complexity.
.Pp
Code should be careful not to rely on an object's absolute path being constant,
since it is possible to move objects between different parents.
.Pp
The
.Va events_lock ,
.Va props_lock
and
.Va lock
members of the
.Nm
structure could be replaced by a single lock.
.Pp
Eventually, if media types other than gfx/audio is required, the
.Nm
layer could handle media associations in a more generic manner.
The names of gfx/audio references is only limited to 64k by
.Fn read_string .
.Pp
The underlying
.Fn object_load
and
.Fn object_save
mechanic is complicated.
.Sh SEE ALSO
.Xr agar 3 ,
.Xr event 3 ,
.Xr prop 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
