.\"	$Csoft: object.3,v 1.67 2004/09/08 07:03:37 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003, 2004 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object interface
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
Agar's
.Nm
layer is responsible for handling:
.Pp
.Bl -bullet -compact -offset indent
.It
Memory management
.It
Object archiving (persistence)
.It
Interdependencies between objects
.It
Object linkage
.It
Shared media (eg. graphics, audio)
.It
Event processing and scheduling
.El
.Pp
.Sh INITIALIZATION AND LINKAGE
.nr nS 1
.Ft "struct object *"
.Fn object_new "void *parent" "const char *name"
.Pp
.Ft "void"
.Fn object_init "void *obj" "const char *type" "const char *name" \
                "const void *ops"
.Pp
.Ft "void"
.Fn object_attach "void *new_parent" "void *obj"
.Pp
.Ft "void"
.Fn object_detach "void *obj"
.Pp
.Ft "void"
.Fn object_move "void *obj" "void *new_parent"
.Pp
.Ft "void *"
.Fn object_root "const void *obj"
.Pp
.Ft "void *"
.Fn object_find_parent "const void *obj" "const char *name" "const char *type"
.Pp
.Ft "int"
.Fn object_copy_name "const void *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn lock_linkage "void"
.Pp
.Ft "void"
.Fn unlock_linkage "void"
.nr nS 0
.Pp
The
.Fn object_new
function allocates and initializes a new, generic object and attaches it to
.Fa parent
if not NULL.
.Pp
The
.Fn object_init
function initializes an object structure.
.Fa name
and
.Fa type
are truncated if they exceed
.Dv OBJECT_NAME_MAX
and
.Dv OBJECT_TYPE_MAX
in length, respectively.
Instances of
.Sq /
characters in
.Fa name
are replaced by
.Sq _ ,
since slash is the path name separator.
If
.Fa ops
is not NULL, it should point to the following structure:
.Bd -literal
struct object_ops {
	void (*init)(void *obj, const char *name);	/* Initialize */
	void (*reinit)(void *obj);			/* Free data */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, struct netbuf *buf);	/* Load data */
	int  (*save)(void *obj, struct netbuf *buf);	/* Save data */
	struct window *(*edit)(void *obj);		/* Edit object */
};
.Ed
.Pp
The
.Fn init
operation initializes an
.Nm
instance.
.Fn reinit
is reponsible for releasing data dynamically allocated by the object (eg.
.Xr map 3
nodes).
.Fn reinit
is invoked prior to rereading an object's data from disk, as part of an
.Dv OBJECT_DATA
page out operation.
.Pp
The
.Fn destroy
operation releases all data allocated by the object, including data allocated
from
.Fn init .
The
.Fn destroy
operation is invoked from
.Fn object_destroy .
It must not free the object structure, and it does not need to bother about
placing the object data back into a consistent state.
.Pp
The following
.Nm
flags are defined:
.Bd -literal
#define OBJECT_RELOAD_PROPS   0x01 /* Don't free props before load */
#define OBJECT_NON_PERSISTENT 0x02 /* Never include in saves */
#define OBJECT_INDESTRUCTIBLE 0x04 /* Not destructible (advisory) */
#define OBJECT_DATA_RESIDENT  0x08 /* Object data is resident (RO) */
#define OBJECT_PRESERVE_DEPS  0x10 /* Don't remove dep if count=0 */
#define OBJECT_STATIC         0x20 /* Don't free() after detach */
#define OBJECT_READONLY       0x40 /* Disallow edition (advisory) */
.Ed
.Pp
The
.Dv OBJECT_RELOAD_PROPS
flag prevents the
.Xr prop 3
table from being cleared as part of a load operation.
.Dv OBJECT_NON_PERSISTENT
prevents the object and its descendents from being archived.
If this flag is set,
.Fn object_page_in
and
.Fn object_page_out
with an argument of
.Dv OBJECT_DATA
become no-ops.
.Pp
The
.Dv OBJECT_INDESTRUCTIBLE
flag advises the object editor not to destroy this object.
.Dv OBJECT_READONLY
advises the object-specific
.Va edit
operation that this object should not be edited.
.Pp
The
.Dv OBJECT_DATA_RESIDENT
flag is set by the
.Nm
system to indicate that the object's data currently resides in memory.
.Pp
The
.Fn object_attach
and
.Fn object_detach
functions respectively link and unlink a child object against a parent
project.
Prior to detaching the object,
.Fn object_detach
cancels scheduled
.Xr timeout 3
events (that do not have the
.Dv TIMEOUT_DETACHABLE
flag set).
These operations raise
.Fn attached
and
.Fn detached
events.
.Pp
.Fn object_move
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
Unlike
.Fn object_detach ,
.Fn object_move
does not cancel scheduled timeout events.
.Pp
The
.Fn object_root
function traverses the object's ancestry and return a pointer to the root
object.
.Fn object_find_parent
traverse the ancestry until a parent object matches the non-NULL
.Fa name
and
.Fa type
arguments.
The object linkage must remain locked throughout the execution of both
.Fn object_root
and
.Fn object_find_parent .
.Pp
The
.Fn object_copy_name
function copies an object's absolute pathname to a fixed-size buffer, and
returns 0 on success and -1 if an error occured, such as the buffer being
too small to hold the full pathname and the terminating NUL.
.Pp
Since
.Fn object_copy_name
must traverse the tree backwards, and an object may move from one parent
to another, the root object provides a lock to protect its linkage.
.Fn lock_linkage
and
.Fn unlock_linkage
acquire and release the world's linkage lock, respectively.
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn object_in_use "const void *obj"
.Pp
.Ft "struct object_dep *"
.Fn object_add_dep "void *obj" "void *depobj"
.Pp
.Ft "void"
.Fn object_del_dep "void *obj" "void *depobj"
.Pp
.Ft "struct object *"
.Fn object_find_dep "const void *obj" "Uint32 ind"
.Pp
.Ft "Uint32"
.Fn object_dep_index "const void *obj" "const void *depobj"
.nr nS 0
.Pp
The
.Fn object_in_use
function returns 1 if the given object
.Fa obj
is used by another object (the two objects must be sharing the same root).
.Pp
The
.Fn object_add_dep
function either creates a new dependency upon
.Fa depobj ,
or increment the reference count if one exists.
.Fn object_del_dep
decrements the reference count upon
.Fa depobj ,
removing it if it reaches 0.
.Pp
The
.Fn object_find_dep
function returns the object of the dependency at the given index, for purposes
of decoding object references in network format.
.Fn object_dep_index
returns the index of a dependency, for purposes of encoding object references
in network format.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "void"
.Fn object_destroy "void *obj"
.Pp
.Ft void
.Fn object_free_data "void *obj"
.Pp
.Ft "void"
.Fn object_free_events "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_props "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_deps "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_children "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_zerodeps "struct object *obj"
.nr nS 0
.Pp
The
.Fn object_destroy
function is called to free all resources reserved by the given object, including
its children (assuming that they are not currently in use).
.Fn object_destroy
also cancels any
.Xr timeout 3
event scheduled for future execution.
To permit static allocation,
.Fn object_destroy
does not invoke
.Xr free 3
on the object structure.
.Pp
Internally,
.Fn object_destroy
invokes
.Fn object_free_events ,
.Fn object_free_props ,
.Fn object_free_deps
and
.Fn object_free_children ,
but these functions may be called directly in order to destroy and reinitialize
the event handler list, the property table and the child objects, respectively.
.Pp
In addition to reinitializing the event handler table,
.Fn object_free_events
also cancels scheduled events.
.Pp
.Fn object_free_children
invokes
.Xr free 3
on the object's children (except those with the
.Dv OBJECT_STATIC
flag set), assuming that none of them are in use.
.Pp
The
.Fn object_free_data
function invokes the
.Va reinit
operation of
.Fa obj
(if there is one) in order to free object data, and clears the
.Dv OBJECT_DATA_RESIDENT
flag.
The
.Va reinit
operation of
.Xr map 3 ,
for example, frees the contents of all nodes of the map.
.Pp
The
.Fn object_free_zerodeps
function clears any dependency table entry that has a reference count of zero
for the given object and its children.
Dependencies with a reference count of zero only occur in objects that have the
.Dv OBJECT_PRESERVE_DEPS
flag set.
.Sh SHARED MEDIA
.Pp
Data that is shared between multiple objects (such as graphics or audio) is
referred to as "shared media".
Agar uses a two-level reference count scheme to perform efficient garbage
collection of this data, and allow object-specific media overrides.
.Pp
The
.Fn object_page_in
and
.Fn object_page_out
functions increment and decrement reference counts that are part of the
.Nm
structure.
A transition of 0->1 on such an object-specific reference count causes
the shared media reference count to be increased (if its reference count
goes 0->1, the media is actually read from disk).
Conversely, a transition of 1->0 on object-specific reference counts cause
the shared media reference count to be decreased (if it goes 1->0, the media
is freed from memory).
.Pp
Once media has been made available through
.Fn object_page_in ,
the
.Va gfx
(for
.Dv OBJECT_GFX )
or
.Va audio
(for
.Dv OBJECT_AUDIO )
member of the
.Nm
structure becomes accessible.
.Pp
Sprites, animations and generated maps are accessed directly through
.Va gfx .
Audio samples are accessed directly through
.Va audio .
See
.Xr gfx 3
and
.Xr audio 3
for more information.
.Sh PERSISTENCE AND PAGING
.nr nS 1
.Ft "int"
.Fn object_load "void *obj"
.Pp
.Ft "int"
.Fn object_save "const void *obj"
.Pp
.Ft "int"
.Fn object_page_in "void *obj" "enum object_page_item item"
.Pp
.Ft "int"
.Fn object_page_out "void *obj" "enum object_page_item item"
.nr nS 0
.Pp
These functions implement archiving of objects (also known as
"serialization" or "flattening" in object-oriented terminology).
Persistent object information such as size, dependencies and
position in the hierarchy are encoded in machine-independent
format (and usually saved to disk or network).
.Pp
The
.Fn load
and
.Fn save
functions of the generic operation vector are responsible for
archiving of data specific to the object's type.
Except for direct subclasses of
.Nm ,
.Fn load
and
.Fn save
must invoke the
.Fn _load
and
.Fn _save
routines of their superclass.
.Pp
The
.Fn object_load
function loads the state of an object and its descendants from
an archive.
The first file found in the search path (the colon-separated
.Sq load-path
config setting) is used.
.Fn object_load
performs the following operations, in order:
.Bl -enum
.It
Cancel scheduled
.Xr timeout 3
events (that don't have the
.Dv TIMEOUT_LOADABLE
flag set).
.It
Load the generic part (the
.Nm
class) of
.Fa obj
and its descendants.
Archived siblings found in the data file are each compared against the
currently attached objects.
If a match is found, the
.Va reinit
op is called.
If there is no currently attached object matching an archived one,
it is dynamically allocated and initialized using the type switch (the
.Va typesw[]
array).
If a currently attached object has no archived counterpart, it is\
destroyed (as long as it is not currently in use).
.It
Resolve the dependencies of
.Fa obj
and its children, so encoded object references may be decoded in the
following step.
.It
Reload the data of
.Fa obj
and its descendants, if currently resident (as a result of a previous
.Fn object_page_in
invocation), decoding object references (which are encoded as indexes into the
dependency table).
.El
.Pp
The
.Fn object_save
function creates an archive of the given object in the save
directory (the
.Sq save-path
config setting).
.Pp
The
.Fn object_page_in
function fetches either object data or shared media.
If the data is already resident, the reference count is incremented.
The
.Fa item
argument may be one of:
.Bd -literal
enum object_page_item {
	OBJECT_GFX,		/* Shared graphics */
	OBJECT_AUDIO,		/* Shared audio */
	OBJECT_DATA		/* Object derivate data */
};
.Ed
.Pp
The
.Fn object_page_out
function decrements the reference count on shared media or object data.
.Pp
These functions return 0 on success or -1 if an error occured.
.Sh POSITIONING
The illusion of objects (such as characters) moving inside a
.Xr map 3
is achieved by maintaining a copy of the object's current projection map.
Most moving game characters provide projection maps called
.Sq [nswe]-idle
and
.Sq [nswe]-move ,
for instance.
The
.Nm
layer is responsible for keeping the object's projection in sync.
When an object is in motion, a two-dimensional "motion" offset (kept in the
.Ft position
structure) is incremented at a specific rate, until it leaves the tile area
.nr nS 1
.Ft "int"
.Fn object_set_projmap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_set_position "void *obj" "struct map *map" "int x" "int y" \
                        "int layer"
.Pp
.Ft "void"
.Fn object_unset_position "void *obj"
.Pp
.Ft "void"
.Fn object_set_input "void *obj" "const char *input_dev"
.nr nS 0
.Pp
The
.Fn object_set_projmap
function searches an object's descendents for a map named
.Fa map_name
and selects it as the current projection map.
.Fn object_set_projmap
returns 0 on success or -1 on failure.
.Pp
The
.Fn object_set_position
function sets the object's unique position to the given coordinates of
.Fa map .
.Fn object_unset_position
causes an object to vanish from its current position, if there is any.
.Pp
The
.Fn object_set_input
function assigns the input device named
.Fa input_dev
to the position associated with
.Fa obj .
.Sh EVENTS
The
.Nm
mechanism generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void"
The object has been attached to a parent object.
This event originates from the parent object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void"
The object has been detached from its parent object.
The linkage lock is held during the execution of the event handler.
This event originates from the parent object.
.It Fn child-attached "void"
Same as
.Fn attached ,
except that the event is sent from the child object to the parent.
.It Fn child-detached "void"
Same as
.Fn detached ,
except that the event is sent from the child object to the parent.
.It Fn moved "void *new_parent"
The object has been moved from its current parent to
.Fa new_parent .
The linkage lock is held during the execution of the event handler.
This event originates from the current parent object.
.It Fn renamed "void"
The object's name has just been modified.
.El
.Sh TROUBLETONS
The positioning functions should probably be moved to a subclass.
.Pp
If the maximum number of references (0xffffffff-2) is reached, the object
remains resident and the reference count is no longer incremented or
decremented.
The behavior of objects when this occurs requires special attention.
.Pp
Code should be careful not to rely on an object's absolute path being constant,
since it is possible to move objects between different parents.
.Pp
Eventually, if media types other than gfx/audio are required, the
.Nm
interface could handle media associations in a more generic manner.
.Sh SEE ALSO
.Xr agar 3 ,
.Xr event 3 ,
.Xr prop 3 ,
.Xr timeout 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
