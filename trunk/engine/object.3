.\"	$Csoft: object.3,v 1.56 2004/02/25 18:12:01 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object interface
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
The Agar game logic is built upon a tree of
.Nm
structures.
The
.Nm
interface is responsible for:
.Bl -bullet -compact
.It
Persistence
.It
Paging and garbage collection of object data
.It
Object dependencies and linkage
.It
Shared data (such as audio and graphics)
.It
Generic events
.It
Generic properties
.El
.Pp
The
.Va flags
member of the
.Nm
structure can take:
.Bd -literal
#define OBJECT_RELOAD_PROPS   0x01 /* Don't free props before load */
#define OBJECT_NON_PERSISTENT 0x02 /* Never include in saves */
#define OBJECT_INDESTRUCTIBLE 0x04 /* Not destructible (advisory) */
#define OBJECT_DATA_RESIDENT  0x08 /* Object data is resident (RO) */
#define OBJECT_PRESERVE_DEPS  0x10 /* Don't remove dep if count=0 */
#define OBJECT_STATIC         0x20 /* Don't free() after detach */
#define OBJECT_READONLY       0x40 /* Disallow edition (advisory) */
.Ed
.Pp
The
.Dv OBJECT_RELOAD_PROPS
flag prevents the
.Xr prop 3
table from being cleared as part of a load operation.
.Dv OBJECT_NON_PERSISTENT
prevents the object and its descendents from being saved as part of a save
operation.
If this flag is set,
.Fn object_page_in
and
.Fn object_page_out
are no-ops (but still increment the reference count).
.Pp
The
.Dv OBJECT_INDESTRUCTIBLE
flag advises the object editor not to destroy this object.
.Dv OBJECT_READONLY
advises the object-specific
.Va edit
operation that this object should not be edited.
.Pp
The
.Dv OBJECT_DATA_RESIDENT
flag is set by the
.Nm
system to indicate that the object's data currently resides in memory.
.Sh INITIALIZATION AND LINKAGE
.nr nS 1
.Ft "struct object *"
.Fn object_new "void *parent" "const char *name"
.Pp
.Ft "void"
.Fn object_init "void *obj" "const char *type" "const char *name" \
                "const void *ops"
.Pp
.Ft "void"
.Fn object_attach "void *new_parent" "void *obj"
.Pp
.Ft "void"
.Fn object_detach "void *obj"
.Pp
.Ft "void"
.Fn object_move "void *obj" "void *new_parent"
.Pp
.Ft "void *"
.Fn object_root "const void *obj"
.Pp
.Ft "int"
.Fn object_copy_name "const void *obj" "char *pathbuf" "size_t pathbuf_len"
.Pp
.Ft "void"
.Fn lock_linkage "void"
.Pp
.Ft "void"
.Fn unlock_linkage "void"
.nr nS 0
.Pp
The
.Fn object_new
function allocates and initializes a new, generic object (object derivates
usually provide their own constructor functions).
If
.Fa parent
is not NULL, the object is attached to a parent.
Otherwise, the object is considered to be the root of an object tree.
.Pp
.Fn object_init
initializes an object.
The
.Fa name
and
.Fa type
are truncated if they exceed
.Dv OBJECT_NAME_MAX
and
.Dv OBJECT_TYPE_MAX
in length, respectively.
Instances of
.Sq /
characters in
.Fa name
are replaced by
.Sq _ ,
since slash is the path name separator.
.Pp
If
.Fa ops
is not NULL, it should point to the following structure:
.Bd -literal
struct object_ops {
	void (*init)(void *obj, const char *name);	/* Initialize */
	void (*reinit)(void *obj);			/* Free data */
	void (*destroy)(void *obj);			/* Release */
	int  (*load)(void *obj, struct netbuf *buf);	/* Load data */
	int  (*save)(void *obj, struct netbuf *buf);	/* Save data */
	struct window *(*edit)(void *obj);		/* Edit object */
};
.Ed
.Pp
The
.Fn object_attach
and
.Fn object_detach
functions respectively link and unlink a child object against a parent
project.
These operations raise
.Fn attached
and
.Fn detached
events.
.Fn object_move
moves
.Fa child
from
.Fa oldparent
to
.Fa newparent ,
raising
.Fn detached ,
.Fn attached
and
.Fn moved
events in order.
.Pp
The
.Fn object_root
function traverses the object's ancestry, until the root is reached.
A pointer to the object itself is returned, if the object is the root.
The linkage must remain locked during the execution of
.Fn object_root .
.Pp
The
.Fn object_copy_name
function copies an object's absolute pathname to a fixed-size buffer, and
returns 0 on success and -1 if an error occured, such as the buffer being
too small to hold the full pathname and the terminating NUL.
.Pp
Since
.Fn object_copy_name
must traverse the tree backwards, and an object may move from one parent
to another, the root object provides a lock to protect its linkage.
.Fn lock_linkage
and
.Fn unlock_linkage
acquire and release the world's linkage lock, respectively.
.Sh DEPENDENCIES
.nr nS 1
.Ft "int"
.Fn object_used "const void *obj"
.Pp
.Ft "struct object_dep *"
.Fn object_add_dep "void *obj" "void *depobj"
.Pp
.Ft "void"
.Fn object_del_dep "void *obj" "void *depobj"
.Pp
.Ft "struct object *"
.Fn object_find_dep "const void *obj" "Uint32 ind"
.Pp
.Ft "Uint32"
.Fn object_dep_index "const void *obj" "const void *depobj"
.nr nS 0
.Pp
The
.Fn object_used
function returns 1 if a given object is referenced from another object
sharing the same root.
.Pp
The
.Fn object_add_dep
function either creates a new dependency upon
.Fa depobj ,
or increment the reference count if one exists.
.Fn object_del_dep
decrements the reference count upon
.Fa depobj ,
removing it if it reaches 0.
.Pp
The
.Fn object_find_dep
function returns the object of the dependency at the given index, for purposes
of decoding object references in network format.
.Fn object_dep_index
returns the index of a dependency, for purposes of encoding object references
in network format.
.Sh GARBAGE COLLECTION
.nr nS 1
.Ft "int"
.Fn object_destroy "void *obj"
.Pp
.Ft void
.Fn object_free_data "void *obj"
.Pp
.Ft "void"
.Fn object_free_events "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_props "struct object *obj"
.Pp
.Ft "void"
.Fn object_free_children "struct object *obj"
.nr nS 0
.Pp
The
.Fn object_destroy
function is called to free all resources reserved by
.Fa ob
and its children.
.Fn object_destroy
returns 0 on success or -1 if the given object (or one of its children)
is currently in use.
To permit static allocation,
.Fn object_destroy
does not call
.Xr free 3 .
.Pp
.Fn object_destroy
calls
.Fn object_free_events ,
.Fn object_free_props
and
.Fn object_free_children ,
but these functions may be called directly in order to clear the event handler
list, the property table and the attached objects, respectively.
.Pp
The
.Fn object_free_data
function invokes the
.Va reinit
operation of
.Fa obj
(if there is one) in order to free object data, and clears the
.Dv OBJECT_DATA_RESIDENT
flag.
The
.Va reinit
operation of
.Xr map 3 ,
for example, frees the contents of all nodes of the map.
.Sh PERSISTENCE AND PAGING
.nr nS 1
.Ft "int"
.Fn object_load "void *obj"
.Pp
.Ft "int"
.Fn object_save "const void *obj"
.Pp
.Ft "int"
.Fn object_page_in "void *obj" "enum object_page_item item"
.Pp
.Ft "int"
.Fn object_page_out "void *obj" "enum object_page_item item"
.nr nS 0
.Pp
The
.Fn object_load
function loads the state of an object and its descendants from
machine-independent format.
The first file found in the search path (the colon-separated
.Sq load-path
config setting) is used.
.Fn object_load
performs the following operations, in order:
.Bl -enum
.It
Load the generic part of
.Fa obj
and its descendants.
Saved child objects found in the data file are each compared against the
currently attached objects.
If a match is found, the
.Va reinit
op is called.
If there is no currently attached object matching a saved object, one is
dynamically allocated and initialized using the type switch (the
.Va typesw[]
array).
If a currently attached object has no matching saved object, it is destroyed
(as long as it is not currently in use).
.It
Resolve the dependencies of
.Fa obj
and its descendants, so encoded object references may be decoded in the
following step.
.It
Reload the data of
.Fa obj
and its descendants, if currently resident (as a result of a previous
.Fn object_page_in
invocation), decoding object references (which are encoded as indexes into the
dependency table).
.El
.Pp
The
.Fn object_save
function writes the state of an object and its descendents to
files/directories in the save directory (the
.Sq save-path
config setting),
in network format.
.Pp
The
.Fn object_page_in
function fetches data associated with an object.
If the data is already resident, its reference count is incremented.
The
.Fa item
argument may be one of:
.Bd -literal
enum object_page_item {
	OBJECT_GFX,		/* Graphics */
	OBJECT_AUDIO,		/* Audio data */
	OBJECT_DATA		/* Object derivate data */
};
.Ed
.Pp
The
.Fn object_page_out
function decrements the reference count on data.
For
.Dv OBJECT_GFX
and
.Dv OBJECT_AUDIO ,
the reference count is decremented on the shared media.
For
.Dv OBJECT_DATA ,
.Fn object_save
and
.Fn object_free_data
are used.
.Pp
These functions return 0 on success or -1 if an error occured.
.Sh MAP OPERATIONS
The illusion of objects (such as characters) moving inside a
.Xr map 3
is achieved by maintaining a copy of the object's current projection map.
Most moving game characters provide projection maps called
.Sq [nswe]-idle
and
.Sq [nswe]-move ,
for instance.
The
.Nm
interface is responsible for keeping the object's projection in sync.
When an object is in motion, a two-dimensional "motion" offset (kept in the
.Ft position
structure) is incremented at a specific rate, until it leaves the tile area
.nr nS 1
.Ft "int"
.Fn object_set_projmap "void *obj" "const char *map_name"
.Pp
.Ft "void"
.Fn object_set_position "void *obj" "struct map *map" "int x" "int y" \
                        "int layer"
.Pp
.Ft "void"
.Fn object_unset_position "void *obj"
.Pp
.Ft "void"
.Fn object_set_input "void *obj" "const char *input_dev"
.nr nS 0
.Pp
The
.Fn object_set_projmap
function searches an object's descendents for a map named
.Fa map_name
and selects it as the current projection map.
.Fn object_set_projmap
returns 0 on success or -1 on failure.
.Pp
The
.Fn object_set_position
function sets the object's unique position to the given coordinates of
.Fa map .
.Fn object_unset_position
causes an object to vanish from its current position, if there is any.
.Pp
The
.Fn object_set_input
function assigns the input device named
.Fa input_dev
to the position associated with
.Fa obj .
.Sh EVENTS
The
.Nm
interface generates the following events:
.Pp
.Bl -tag -width 2n
.It Fn attached "void"
The object has been attached to a parent object.
This event originates from the parent object.
The linkage lock is held during the execution of the event handler.
.It Fn detached "void"
The object has been detached from its parent object.
The linkage lock is held during the execution of the event handler.
This event originates from the parent object.
.It Fn moved "void *new_parent"
The object has been moved from its current parent to
.Fa new_parent .
The linkage lock is held during the execution of the event handler.
This event originates from the current parent object.
.El
.Sh TROUBLETONS
If the maximum number of references (0xffffffff-2) is reached, the object
remains resident and the reference count is no longer incremented or
decremented.
The behavior of objects when this occurs requires special attention.
.Pp
Code should be careful not to rely on an object's absolute path being constant,
since it is possible to move objects between different parents.
.Pp
Eventually, if media types other than gfx/audio is required, the
.Nm
interface could handle media associations in a more generic manner.
.Sh SEE ALSO
.Xr agar 3 ,
.Xr event 3 ,
.Xr prop 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
