.\"	$Csoft: object.3,v 1.28 2003/03/25 13:27:27 vedge Exp $
.\"
.\" Copyright (c) 2001, 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistribution of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd March 17, 2002
.Dt OBJECT 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm object
.Nd agar object layer
.Sh SYNOPSIS
.Bd -literal
#include <engine/object.h>
.Ed
.Sh DESCRIPTION
The agar
.Nm
layer implements:
.Pp
.Bl -bullet -compact
.It
Garbage collection.
.It
Graphical/audio data management.
.It
States saving to network format.
.It
State loading from network format.
.It
Positions on maps (back references for game mode).
.It
Dependencies between objects.
.El
.Sh INITIALIZATION
.nr nS 1
.Ft "struct object *"
.Fn object_new "char *type" "char *name" "char *archive" "int flags" \
               "const void *ops"
.Ft "void"
.Fn object_init "struct object *ob" "char *type" "char *name" "char *archive" \
                "int flags" "const void *ops"
.Pp
.Ft "void"
.Fn object_destroy "void *ob"
.nr nS 0
.Pp
The
.Fn object_new
function allocates, initializes and attaches a new, generic object to the
world.
The
.Fn object_init
function initializes
.Fa ob
as an object of type
.Fa type .
If
.Fa name
exceeds
.Fa OBJECT_MAX_NAME
or
.Fa type
exceeds
.Fa OBJECT_MAX_TYPE ,
a fatal condition is raised.
.Pp
If the
.Fa archive
argument is not NULL, it identifies a
.Xr fobj 3
(with the
.Sq .fob
suffix) to be looked up in the data directories (the
.Sq path.data_path
setting) and loaded.
.Pp
The
.Fa ops
argument, if not NULL, is a pointer to the following structure:
.Bd -literal
struct object_ops {
	void	(*destroy)(void *ob);		/* Free resources */
	int	(*load)(void *ob, int fd);	/* Load from fd */
	int	(*save)(void *ob, int fd);	/* Save to fd */
};
.Ed
.Pp
The
.Fa flags
argument may contain:
.Bd -literal
#define OBJECT_ART		0x01	/* Load graphics */
#define OBJECT_ART_CACHE	0x02	/* Keep graphics cached */
#define OBJECT_ART_CAN_FAIL	0x04	/* Graphic load can fail */
#define OBJECT_AUDIO		0x08	/* Load audio */
#define OBJECT_AUDIO_CACHE	0x10	/* Keep audio cached */
#define OBJECT_AUDIO_CAN_FAIL	0x20	/* Audio load can fail */
#define OBJECT_CANNOT_MAP	0x40	/* Don't insert in object tables */
#define OBJECT_STATIC		0x80	/* Don't destroy (if attached) */
.Ed
.Pp
The
.Fn object_destroy
function is called to free all resources associated with
.Fa ob .
.Sh SAVING STATES
.nr nS 1
.Ft "int"
.Fn object_load "void *ob"
.Pp
.Ft "int"
.Fn object_load_from "void *ob" "char *path"
.Pp
.Ft "int"
.Fn object_save "void *ob"
.Pp
.Ft "int"
.Fn object_path "char *name" "const char *suffix" "char *dst" "size_t dst_size"
.Pp
.nr nS 0
The
.Fn object_load
function loads the state of
.Fa ob
from the first file found in data directories.
.Fn object_loadfrom
loads the state of
.Fa ob
from the file at
.Fa path .
.Fn object_save
saves the state of
.Fa ob
to the user's data directory.
.Pp
The
.Fn object_path
function searches the data directories for a file matching the
.Fa name
and
.Fa suffix
arguments.
If a file is found, up to
.Fa dst_size
- 1 bytes of its path name are copied to
.Fa dst ,
and the result is NUL-terminated.
.Fn object_path
returns 0 on success or -1 if an error occured.
.Sh MAP OPERATIONS
Agar maintains a stack of noderef structures for each node on a
.Xr map 3 .
Some types of noderefs point to specific data associated with an object,
such as sprites or animations.
Game objects (such as characters) store a back reference to a single node on a
.Xr map 3 .
This node is expected to contain an arbitrary amount of noderefs that move
along with the object on the map.
.Pp
.nr nS 1
.Ft "void"
.Fn object_set_position "void *ob" "struct noderef *nref" "struct map *map" \
                        "Uint32 x" "Uint32 y"
.Pp
.Ft "void"
.Fn object_move "void *ob" "struct map *dst_map" "Uint32 dst_x" "Uint32 dst_y"
.Pp
.Ft "void"
.Fn object_control "void *ob" "struct input *in" "int center"
.Pp
.Ft "int"
.Fn object_vanish "void *ob"
.nr nS 0
.Pp
The
.Fn object_set_position
function sets the object's unique position to the node at the
.Fa x ,
.Fa y
coordinates of
.Fa map .
.Fn object_set_position
does not create any noderef but if there is currently a position, its
noderefs are removed.
.Fn object_set_position
is usually called after a new noderef is created (with
.Fn node_add_sprite
or
.Fn node_add_anim ,
for example), in order to update the object's back reference.
.Pp
The
.Fn object_move
function moves
.Fa ob
from its current position to the
.Fa dst_x
and
.Fa dst_y
coordinates of
.Fa dst_map .
.Pp
The
.Fn object_control
function assigns the input device
.Fa in
to the position associated with
.Fa ob ,
centering the view and enabling soft-scrolling if
.Fa center
is non-zero .
.Pp
The
.Fn object_vanish
function removes the current position associated with
.Fa ob
by setting
.Va pos
to
.Dv NULL ,
as well as removing the associated noderef.
.Fn object_vanish
returns 0 on success, -1 on error.
.Sh OBJECT TABLES
These functions load and save arrays of object names with reference counts.
This allows load/save routines to keep dependency lists and reference objects
with indexes instead of strings.
.Pp
.nr nS 1
.Ft "struct object_table *"
.Fn object_table_new "void"
.Pp
.Ft "void"
.Fn object_table_destroy "struct object_table *table"
.Pp
.Ft "void"
.Fn object_table_insert "struct object_table *table" "struct object *obj"
.Pp
.Ft "void"
.Fn object_table_save "struct fobj_buf *buf" "struct object_table *table"
.Pp
.Ft "struct object_table *"
.Fn object_table_load "int fd" "char *objname"
.nr nS 0
.Pp
The
.Fn object_table_new
function allocates, initializes and return a new object table with 0 elements.
The
.Fn object_table_destroy
frees
.Fa table .
.Pp
The
.Fn object_table_insert
function inserts
.Fa obj
in
.Fa table .
.Pp
The
.Fn object_table_save
function write
.Fa table
to
.Fa buf .
The
.Fn object_table_load
function allocates and reads the object table from
.Fa fd .
.Fn object_table_load
returns the new object table, or NULL on failure.
.Sh SEE ALSO
.Xr agar 3
.Sh HISTORY
The
.Nm
interface appeared in Agar 1.0
.\" .Sh CAVEATS
