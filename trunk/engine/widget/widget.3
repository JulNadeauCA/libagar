.\"	$Csoft: widget.3,v 1.33 2003/06/08 23:53:17 vedge Exp $
.\"
.\" Copyright (c) 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <engine/widget/widget.h>
.Ed
.Sh DESCRIPTION
Agar widgets are derived from the
.Nm
object and organized in a tree structure.
Widgets fall under one of three categories:
.Bl -tag -width "Composite widgets "
.It Container widgets
Containers arrange the position and geometry of their children in a specific
order.
.Xr hbox 3 ,
.Xr vbox 3
and
.Xr window 3
are the most commonly used container widgets.
.It Composite widgets
Composite widgets create pre-defined child widgets and arrange them in a
specific manner.
For example, the
.Xr tlist 3
widget attaches a vertical
.Xr scrollbar 3
to itself.
Composite widgets can behave like containers as well, like
.Xr window 3
which attaches a
.Xr titlebar 3
widget to itself but accepts other widgets.
.It Simple widgets
Simple widgets do not contain any children.
.Xr button 3
and
.Xr label 3
are examples of simple widgets.
The behavior is undefined if one attempts to attach children to such widgets.
.El
.Sh INITIALIZATION
.nr nS 1
.Ft "void"
.Fn widget_init "void *widget" "const char *type" "const void *widget_ops" \
                "int flags"
.nr nS 0
.Pp
The
.Fn widget_init
function initializes a generic
.Nm
structure.
Acceptable
.Fa flags
include:
.Pp
.Bd -literal
#define WIDGET_FOCUSABLE	  0x01	/* Can grab focus */
#define WIDGET_FOCUSED		  0x02	/* Holds focus (optimization) */
#define WIDGET_UNFOCUSED_MOTION	  0x04	/* Unfocused mousemotion */
#define WIDGET_UNFOCUSED_BUTTONUP 0x08	/* Unfocused mousebuttonup */
#define WIDGET_CLIPPING		  0x10	/* Enable clipping */
#define WIDGET_WFILL		  0x20	/* Fill available width */
#define WIDGET_HFILL		  0x40	/* Fill available height */
.Ed
.Pp
Only widgets with the
.Dv WIDGET_FOCUSABLE
flag are able to gain focus.
.Dv WIDGET_UNFOCUSED_MOTION
and
.Dv WIDGET_UNFOCUSED_BUTTONUP
enable reception of
.Sq window-mousemotion
and
.Sq window-mousebuttonup
events, respectively - these events are otherwise only posted to widgets with
the
.Dv WIDGET_FOCUSED
flag.
.Pp
.Dv WIDGET_CLIPPING
causes a clipping rectangle (as set by
.Xr SDL_SetClipRect 3 )
to surround the widget area for the duration of the draw operation.
.Pp
The
.Dv WIDGET_WFILL
and
.Dv WIDGET_HFILL
flags indicate to container widgets that the widget wishes to allocate the
remaining width or height inside the container area.
.Pp
The
.Fa widget_ops
argument to
.Fn widget_init
is a pointer to the following structure:
.Bd -literal
struct widget_ops {
	const struct object_ops	obops;		/* Generic object(3) ops */
	void (*draw)(void *p);			/* Rendering routine */
	void (*scale)(void *p, int w, int h);	/* Size request routine */
};
.Ed
.Sh GEOMETRY MANAGEMENT
The
.Va scale
operation is invoked to set the size of a widget.
With
.Fa w ,
.Fa h
arguments of -1,
.Va scale
is expected to choose a default, minimum geometry sufficient to display the
widget aesthetically.
.Pp
Containers set the
.Va w ,
.Va h
geometries and relative
.Va x ,
.Va y
positions of their children prior to invoking their
.Va scale
operation (with arguments of
.Va w ,
.Va h ) .
.Pp
Widgets must not make any assumptions about their own position inside their
parent container.
.Sh FOCUS STATE
.nr nS 1
.Ft "int"
.Fn widget_holds_focus "void *widget"
.Pp
.Ft "void"
.Fn widget_focus "void *widget"
.nr nS 0
.Pp
The
.Fn widget_holds_focus
function returns 1 if a widget has the
.Dv WIDGET_FOCUSED
flag set.
Note that this flag is not effective (although it may affect widget layout)
unless all parent widgets have the flag set as well.
.Pp
.Fn widget_focus
sets the
.Dv WIDGET_FOCUSED
flag on a widget and all of its parent widgets, until the parent window is
reached.
.Pp
The effect of the focus state is determined by the widget implementation.
Usually it enables reception of keyboard and mouse motion events and affects
the widget appearance.
.Pp
Window focus is independent from widget focus; the highest window on the
stack always holds focus; the
.Fn WINDOW_FOCUSED
macro may be used to test this.
.Sh COLOR SCHEME
.nr nS 1
.Ft void
.Fn widget_map_color "struct widget *wid" "int index" "const char *name" \
                     "Uint8 r" "Uint8 g" "Uint8 b" "Uint8 a"
.Pp
.Ft int
.Fn widget_push_color "struct widget *wid" "Uint32 color"
.Pp
.Ft void
.Fn widget_pop_color "struct widget *wid"
.Pp
.Ft Uint32
.Fn WIDGET_COLOR "struct widget *wid" "int index"
.Pp
.nr nS 0
.Pp
The
.Fn widget_map_color
function adds a new entry to a widget's color scheme, with a default color
composed from the given RGBA component values.
The rendering routines obtain the colors using
.Fa index ,
but the colors may also be referenced by their
.Fa name
string.
.Pp
The
.Fn widget_push_color
function pushes a color in display format onto a widget's color stack.
.Fn widget_pop_color
pops the highest color off a widget's color stack.
.Pp
The
.Fn WIDGET_COLOR
macro returns the color at index
.Fa index .
.Sh COORDINATES
.nr nS 1
.Ft int
.Fn widget_area "void *widget" "int x" "int y"
.nr nS 0
.Pp
The
.Fn widget_area
function returns 1 if absolute view coordinates
.Fa x
and
.Fa y
are inside the area allocated by the widget.
.Sh RENDERING
The
.Va draw
operation, if not NULL, is expected to render the widget to the video display.
Note that this operation is automatically invoked on children.
.Pp
.nr nS 1
.Ft void
.Fn widget_blit "void *widget" "SDL_Surface *src" "int x" "int y"
.Pp
.Ft void
.Fn widget_put_pixel "void *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn primitives.box "void *widget" "int x" "int y" "int w" "int h" "int z" \
                   "int ncolor"
.Pp
.Ft void
.Fn primitives.frame "void *widget" "int x" "int y" "int w" "int h" \
                     "int ncolor"
.Pp
.Ft void
.Fn primitives.circle "void *widget "int x" "int y" "int radius" \
                      "int ncolor"
.Pp
.Ft void
.Fn primitives.line "void *widget" "int x1" "int y1" "int x2" "int y2" \
                    "int ncolor"
.Pp
.Ft void
.Fn primitives.line2 "void *widget" "int x1" "int y1" "int x2" "int y2" \
                    "int ncolor"
.Pp
.Ft void
.Fn primitives.rect_outlined "void *widget" "int x" "int y" "int w" "int h" \
                             "int ncolor"
.Pp
.Ft void
.Fn primitives.rect_filled "void *widget" "SDL_Rect *rd" "int ncolor"
.Pp
.nr nS 0
The
.Fn widget_blit
function performs a surface blit from
.Fa src
to the video display at widget-relative coordinates
.Fa x
and
.Fa y .
.Pp
The
.Fn widget_put_pixel
function writes a pixel of value
.Fa color
at widget-relative coordinates
.Fa x ,
.Fa y
relative to
.Fa widget ,
assuming the pixel is inside the current clipping rectangle as set by
.Xr SDL_SetClipRect 3 .
.Pp
Primitive functions are part of the
.Va primitives
structure, since the underlying functions may change at runtime (ie. for
OpenGL mode and GUI emulation).
The
.Fa ncolor
argument is an index into the widget's color array.
.Pp
.Fn primitives.box
draws a 3D-style box of size
.Fa w ,
.Fa h
at
.Fa x ,
.Fa y .
The
.Fa z
argument indicates the apparent depth.
.Pp
.Fn primitives.frame
draws a 3D-style frame of size
.Fa w ,
.Fa h
at
.Fa x ,
.Fa y .
.Pp
.Fn primitives.circle
draws a circle around the point at
.Fa x ,
.Fa y .
.Pp
.Fn primitives.line
draws a line from
.Fa x1 ,
.Fa y1
to
.Fa x2 ,
.Fa y2 .
.Fn primitives.line2
is a variant which draws two lines with a RGB difference of +50,+50,+50.
.Pp
.Fn primitives.rect_outlined
draws a border of size
.Fa w ,
.Fa h
at
.Fa x ,
.Fa y .
.Pp
.Fn primitives.rect_filled
draws a filled rectangle of size
.Fa rd->w ,
.Fa rd->h
at
.Fa rd->x ,
.Fa rd->y .
.Sh BINDINGS
The
.Nm widget
structure contains a list of pointers to values that the widgets are able
to read and manipulate directly.
Widget bindings eliminate the need for event handlers for widgets manipulating
variables of primitive data types.
For example, the
.Xr scrollbar 3
widget defines
.Sq value ,
.Sq min
and
.Sq max
as
.Dv WIDGET_INT
bindings
and
.Xr textbox 3
edits a
.Dv WIDGET_STRING
binding.
.Pp
All widgets provide default bindings, which point to data allocated and
initialized by the widget itself.
.Fn widget_bind
is called to override those default bindings.
.nr nS 1
.Ft "struct widget_binding *"
.Fn widget_bind "void *widget" "const char *binding" \
                "enum widget_binding_type type" "..."
.Pp
.Ft "struct widget_binding *"
.Fn widget_binding_get "void *widget" "const char *binding" "void *res"
.Pp
.Ft "struct widget_binding *"
.Fn widget_binding_get_locked "void *widget" "const char *binding" "void *res"
.Pp
.Ft void
.Fn widget_binding_lock "struct widget_binding *binding"
.Pp
.Ft void
.Fn widget_binding_unlock "struct widget_binding *binding"
.Pp
.Ft int
.Fn widget_get_bool "void *widget" "const char *binding"
.Pp
.Ft int
.Fn widget_get_int "void *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn widget_get_uint8 "void *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn widget_get_sint8 "void *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn widget_get_uint16 "void *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn widget_get_sint16 "void *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn widget_get_uint32 "void *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn widget_get_sint32 "void *widget" "const char *binding"
.Pp
.Ft float
.Fn widget_get_float "void *widget" "const char *binding"
.Pp
.Ft double
.Fn widget_get_double "void *widget" "const char *binding"
.Pp
.Ft char *
.Fn widget_get_string "void *widget" "const char *binding"
.Pp
.Ft size_t
.Fn widget_copy_string "void *widget" "const char *binding" "char *dst" \
                       "size_t dst_size"
.Pp
.Ft void *
.Fn widget_get_pointer "void *widget" "const char *binding"
.Pp
.Ft void
.Fn widget_set_bool "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_int "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_uint8 "void *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn widget_set_sint8 "void *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn widget_set_uint16 "void *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn widget_set_sint16 "void *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn widget_set_uint32 "void *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn widget_set_sint32 "void *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn widget_set_float "void *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn widget_set_double "void *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn widget_set_string "void *widget" "const char *binding" "char *s"
.Pp
.Ft void
.Fn widget_set_pointer "void *widget" "const char *binding" "void *p"
.Pp
.nr nS 0
The
.Fn widget_bind
function either overrides or creates a new binding.
.Pp
If
.Fa type
is
.Dv WIDGET_PROP ,
the following arguments are:
.Bl -tag -width "struct object * " -compact
.It struct object *
The object that holds the property.
.It const char *
The property identifier.
.El
.Pp
If
.Fa type
is
.Dv WIDGET_STRING ,
the following arguments are:
.Bl -tag -width "pthread_mutex_t * " -compact
.It pthread_mutex_t *
A lock to acquire when manipulating the data, or NULL
.It const char *
A pointer to the string.
.It size_t
The full size of the string buffer.
.El
.Pp
Otherwise, the following arguments are:
.Bl -tag -width "pthread_mutex_t * " -compact
.It pthread_mutex_t *
A lock to acquire when manipulating the data, or NULL.
.It void *
A pointer to the data.
.El
.Pp
Correct values for the
.Fa type
argument include:
.Bd -literal
enum widget_binding_type {
	WIDGET_NONE,
	WIDGET_BOOL,
	WIDGET_INT,
	WIDGET_UINT8,
	WIDGET_SINT8,
	WIDGET_UINT16,
	WIDGET_SINT16,
	WIDGET_UINT32,
	WIDGET_SINT32,
	WIDGET_FLOAT,
	WIDGET_DOUBLE,
	WIDGET_STRING,
	WIDGET_POINTER,
	WIDGET_PROP
}
.Ed
.Pp
The
.Fn widget_binding_get
function returns a matching binding, or NULL if none was found.
If a binding was found, a pointer to it is written to
.Fa res .
.Fn widget_binding_get_locked
is a variant that does not unlock the binding before returning, so the
caller must invoke
.Fa widget_binding_unlock
when done manipulating the data.
.Pp
The
.Fn widget_get_TYPE
and
.Fn widget_set_TYPE
variants manipulate the bound values atomically.
.Fn widget_get_string
returns a copy of the string (or NULL on failure).
.Fn widget_copy_string
copies up to
.Fa dst_size
- 1 bytes from the string to
.Fa dst ,
NUL-terminating the result and returning the number of bytes that would
have been copied if
.Fa dst_size
was unlimited.
.Sh THREAD SAFETY
In event context, the widgets can assume that their parent window is locked,
and internal properties of other widgets inside the same window can be
manipulated (for widgets inside other windows, explicit locking is required).
.Pp
The visibility of any window may be altered, and new windows may be attached
immediately.
In event context, window detach operations are deferred until processing of
the current event is complete.
.Sh EVENTS
The
.Nm
structure generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "void"
The widget is now visible.
.It Fn widget-hidden "void"
The widget is no longer visible.
.It Fn widget-gainfocus "void"
The widget now holds focus inside its container.
.It Fn widget-lostfocus "void"
The widget no longer holds focus.
.It Fn widget-bound "struct widget_binding *binding"
A widget binding has been added or modified.
.El
.Pp
.Sh SEE ALSO
.Xr agar 3 ,
.Xr window 3 ,
.Xr bitmap 3 ,
.Xr button 3 ,
.Xr checkbox 3 ,
.Xr graph 3 ,
.Xr label 3 ,
.Xr mapview 3 ,
.Xr palette 3 ,
.Xr radio 3 ,
.Xr scrollbar 3 ,
.Xr textbox 3 ,
.Xr tlist 3
.Sh HISTORY
The
.Nm
interface first appeared in Agar 1.0.
.Sh BUGS
The
.Fn widget_binding_get
interface is too complicated.
.Pp
The primitives should use a current color (OpenGL-style), but that could not be
efficiently thread safe.
