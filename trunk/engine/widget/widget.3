.\"	$Csoft: widget.3,v 1.25 2003/03/09 00:34:43 vedge Exp $
.\"
.\" Copyright (c) 2002, 2003 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <engine/widget/widget.h>
.Ed
.Sh DESCRIPTION
Agar widgets are derived from the
.Nm
structure.
Widgets are attached to window
.Xr region 3
structures, and their coordinates and geometry are variable.
.Sh LOCKING POLICIES
Widget initialization and free routines do not need to be concerned about
locking.
.Pp
In event context, the widgets can assume that their parent window is locked,
so internal properties of other widgets inside the same window can be
manipulated (for widgets inside other windows, explicit locking is required).
.Pp
The visibility of any window may be altered, and new windows may be attached
immediately.
Detach operations on existing windows are deferred until the current event is
processed.
.Pp
Widget structure members that can be manipulated from code outside of
the event loop (such as the
.Xr scrollbar 3
range or the
.Xr textbox 3
text) must provide a thread-safe interface.
.Sh POSITIONMENT
The effective position and geometry of widgets is managed by the widget
container (ie.
.Xr region 3
or another widget), and is hidden from the widget layer by macros.
.Sh INITIALIZATION
.nr nS 1
.Ft void
.Fn widget_init "struct widget *wid" "char *name" \
                "const void *widget_ops" "int rw" "int rh"
.nr nS 0
.Pp
The
.Fn widget_init
function initializes a widget structure.
.Fa widget_ops
is a pointer to the following structure:
.Bd -literal
struct widget_ops {
	const struct object_ops	obops;		/* Object ops */

	void	 (*widget_draw)(void *);	/* Rendering routine */
	void	 (*widget_update)(void *);	/* Update routine */
};
.Ed
.Pp
Since widgets don't hold persistent properties, their identification
string is simply the widget type followed by a random number.
.Pp
The widget initially requests an area of size
.Fa rw
x
.Fa rh .
If
.Fa rw
and
.Fa rh
are greater than zero, they are considered percentiles of the total
space occupied by the parent region.
If they are zero, the widget requests all available space inside the region.
If
.Fa rw
or
.Fa rh
is negative, the widget provides a default geometry.
.Pp
The
.Fa flags
can be changed at runtime, and may include:
.Pp
.Bd -literal
#define WIDGET_NO_FOCUS		  0x01	/* Cannot gain focus. */
#define WIDGET_UNFOCUSED_MOTION	  0x02	/* Catch window-mousemotion
					   when widget isn't focused. */
#define WIDGET_UNFOCUSED_BUTTONUP 0x04	/* Catch window-mousebuttonup
					   when widget isn't focused, */
#define WIDGET_CLIPPING		  0x08	/* Set the clipping rectangle to
					   the widget area before draw. */
.Ed
.Sh COLOR SCHEME
.nr nS 1
.Ft void
.Fn widget_map_color "struct widget *wid" "int index" "char *name" "Uint8 r" \
                     "Uint8 g" "Uint8 b"
.Pp
.Ft Uint32
.Fn WIDGET_COLOR "struct widget *wid" "int index"
.Pp
.nr nS 0
.Pp
The
.Fn widget_map_color
function registers a color referenced by the null-terminated string pointed
to by
.Fa name ,
with a default value of
.Fa r ,
.Fa g
and
.Fa b .
The
.Fa index
argument is an index into the widget color table (an arbitrary-sized array of
color values).
This allows the color scheme to change at run time without expensive
lookup operations in widget rendering routines.
.Pp
The
.Fn WIDGET_COLOR
macro returns the color at index
.Fa index .
.Sh COORDINATES
.nr nS 1
.Ft void
.Fn widget_get_position "struct widget *wid" "Sint16 *x" "Sint16 *y"
.Pp
.Ft void
.Fn widget_set_geometry "struct widget *wid" "Uint16 *w" "Uint16 *h"
.Pp
.Ft void
.Fn widget_set_position "struct widget *wid" "Sint16 x" "Sint16 y"
.Pp
.Ft void
.Fn widget_set_geometry "struct widget *wid" "Uint16 w" "Uint16 h"
.Pp
.Ft Uint32
.Fn WIDGET_ABSX "struct widget *wid"
.Pp
.Ft Uint32
.Fn WIDGET_ABSY "struct widget *wid"
.Pp
.Ft bool
.Fn WIDGET_INSIDE "struct widget *wid" "Sint16 x" "Sint16 y"
.Pp
.Ft bool
.Fn WIDGET_INSIDE_RELATIVE "struct widget *wid" "Sint16 x" "Sint16 y"
.Pp
.nr nS 0
The
.Fn widget_set_position
and
.Fn widget_get_position
change and return the widget's effective position inside the window,
respectively.
.Pp
The
.Fn widget_set_geometry
and
.Fn widget_get_geometry
change and return the widget's effective geometry, respectively.
.Pp
The
.Fn WIDGET_ABSX
and
.Fn WIDGET_ABSY
macros return the absolute coordinates of a widget.
.Pp
The
.Fn WIDGET_INSIDE
macro evaluates to true if absolute coordinates
.Fa x
and
.Fa y
are inside the widget area.
The
.Fn WIDGET_INSIDE_RELATIVE
macro evaluates to true if widget-relative coordiates
.FA x
and
.Fa y
are inside the widget area.
.Sh RENDERING
.nr nS 1
.Ft void
.Fn widget_blit "struct widget *wid" "SDL_Surface *src" "int xoffs" \
                "int yoffs"
.Pp
.Ft void
.Fn WIDGET_PUT_PIXEL "struct widget *wid" "Sint16 x" "Sint16 y" "Uint32 color"
.Pp
.Ft void
.Fn WIDGET_PUT_ALPHAPIXEL "struct widget *wid" "Sint16 x" "Sint16 y" \
                          "Uint32 color" "Uint8 a"
.Pp
.Ft void
.Fn WIDGET_FOCUS "struct widget *wid"
.nr nS 0
.Pp
The
.Fn widget_blit
function performs a blit from source surface
.Fa src
to the display at
.Fa xoffs ,
.Fa yoffs
relative to the widget's current coordinates.
.Pp
The
.Fn WIDGET_PUT_PIXEL
macro writes a pixel of value
.Fa color
at coordinates
.Fa x ,
.Fa y
on the widget surface.
The
.Fn WIDGET_PUT_ALPHAPIXEL
macro writes a pixel at coordinates
.Fa x ,
.Fa y
of the widget, after alpha-blending the pixel using alpha value
.Fa a .
.Pp
The
.Fn WIDGET_FOCUS
macro gives focus to a widget and posts a
.Fn widget-gainfocus
event.
.Sh BINDINGS
The
.Nm widget
structure contains a list of pointers to values that the widgets are able
to read and manipulate directly.
Widget bindings eliminate the need for event handlers for widgets dealing
with simple types of data.
For example, the
.Xr scrollbar
widget defines
.Sq value ,
.Sq min
and
.Sq max
as
.Ft int
bindings.
.Pp
All widgets provide default bindings, which point to data allocated and
initialized by the widget itself.
The
.Fn widget_bind
function is called to override the default bindings.
.nr nS 1
.Ft "struct widget_binding *"
.Fn widget_bind "void *widget" "const char *binding" \
                "enum widget_binding_type type" "..."
.Pp
.Ft "struct widget_binding *"
.Fn widget_binding_get "void *widget" "const char *binding" "void *res"
.Pp
.Ft "struct widget_binding *"
.Fn widget_binding_get_locked "void *widget" "const char *binding" "void *res"
.Pp
.Ft void
.Fn widget_binding_unlock "struct widget_binding *binding"
.Pp
.Ft int
.Fn widget_get_bool "void *widget" "const char *binding"
.Pp
.Ft int
.Fn widget_get_int "void *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn widget_get_uint8 "void *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn widget_get_sint8 "void *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn widget_get_uint16 "void *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn widget_get_sint16 "void *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn widget_get_uint32 "void *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn widget_get_sint32 "void *widget" "const char *binding"
.Pp
.Ft float
.Fn widget_get_float "void *widget" "const char *binding"
.Pp
.Ft double
.Fn widget_get_double "void *widget" "const char *binding"
.Pp
.Ft char *
.Fn widget_get_string "void *widget" "const char *binding"
.Pp
.Ft void *
.Fn widget_get_pointer "void *widget" "const char *binding"
.Pp
.Ft void
.Fn widget_set_bool "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_int "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_uint8 "void *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn widget_set_sint8 "void *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn widget_set_uint16 "void *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn widget_set_sint16 "void *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn widget_set_uint32 "void *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn widget_set_sint32 "void *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn widget_set_float "void *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn widget_set_double "void *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn widget_set_string "void *widget" "const char *binding" "char *s"
.Pp
.Ft void
.Fn widget_set_pointer "void *widget" "const char *binding" "void *p"
.Pp
.nr nS 0
The
.Fn widget_bind
function either overrides or creates a new binding.
.Pp
If
.Fa type
is
.Dv WIDGET_PROP ,
the following arguments are:
.Bl -tag -width "struct object * " -compact
.It struct object *
The object that holds the property.
.It char *
The property identifier.
.El
.Pp
Otherwise, the following arguments are:
.Bl -tag -width "pthread_mutex_t * " -compact
.It pthread_mutex_t *
A lock to acquire when manipulating the data.
.It void *
A pointer to the data.
.El
.Pp
Correct values for the
.Fa type
argument include:
.Bd -literal
enum widget_binding_type {
	WIDGET_NONE,
	WIDGET_BOOL,
	WIDGET_INT,
	WIDGET_UINT8,
	WIDGET_SINT8,
	WIDGET_UINT16,
	WIDGET_SINT16,
	WIDGET_UINT32,
	WIDGET_SINT32,
	WIDGET_FLOAT,
	WIDGET_DOUBLE,
	WIDGET_STRING,
	WIDGET_POINTER,
	WIDGET_PROP
}
.Ed
.Pp
The
.Fn widget_binding_get
function returns a matching binding, or NULL if none was found.
If a binding was found, a pointer to it is written to
.Fa res .
.Fn widget_binding_get_locked
is a variant that does not unlock the binding before returning, so the
caller must invoke
.Fa widget_binding_unlock
when done manipulating the data.
.Pp
The
.Fa widget_get_TYPE
and
.Fa widget_set_TYPE
variants manipulate the bound values atomically.
.Sh EVENTS
The
.Nm
structure generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "struct window *win"
Widget is now visible inside window
.Fa win .
.It Fn widget-hidden "struct window *win"
Widget is no longer visible inside window
.Fa win .
.It Fn widget-gainfocus "void"
Widget now holds focus inside its parent window.
.It Fn widget-lostfocus "void"
Widget no longer holds focus inside its parent window.
.It Fn widget-scaled "int w" "int h"
Widget's parent region was resized to
.Fa w
by
.Fa h
pixels.
Widgets can assume that a
.Fn widget-scaled
event is always generated before
.Fn widget_draw
is first called.
Widgets can adopt any geometry when handling
.Fn widget-scaled
events, as long as they fit inside 
.Fa w
by
.Fa h
pixels.
The order of input events and draw operation is undefined if widgets
overlap.
.El
.Pp
.Sh SEE ALSO
.Xr agar 3 ,
.Xr window 3 ,
.Xr region 3 ,
.Xr bitmap 3 ,
.Xr button 3 ,
.Xr checkbox 3 ,
.Xr graph 3 ,
.Xr label 3 ,
.Xr mapview 3 ,
.Xr palette 3 ,
.Xr radio 3 ,
.Xr scrollbar 3 ,
.Xr textbox 3 ,
.Xr tlist 3
.Sh HISTORY
The
.Nm
structure first appeared in Agar 1.0.
