.\"	$Csoft: widget.3,v 1.60 2005/03/11 08:56:33 vedge Exp $
.\"
.\" Copyright (c) 2002, 2003, 2004, 2005 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <engine/widget/widget.h>
.Ed
.Sh DESCRIPTION
Agar widgets are subclasses of
.Nm ,
organized in a tree structure.
Widgets fall under one of three categories:
.Bl -tag -width "Composite widgets "
.It Container widgets
Containers arrange the position and geometry of their children in a specific
order.
.Xr hbox 3 ,
.Xr vbox 3
and
.Xr window 3
examples of container widgets.
.It Composite widgets
Composite widgets create pre-defined child widgets and arrange them in a
specific manner.
For example, the
.Xr tlist 3
widget attaches a vertical
.Xr scrollbar 3
to itself.
Composite widgets can behave like containers as well, like
.Xr window 3
which attaches a
.Xr titlebar 3
widget to itself but accepts other widgets.
.It Simple widgets
Simple widgets do not contain any children.
.Xr button 3
and
.Xr label 3
are examples of simple widgets.
The behavior is undefined if one attempts to attach children to such widgets.
.El
.Sh INHERITANCE HIERARCHY
.Pp
.Xr object 3 ->
.Nm .
.Sh INITIALIZATION
.nr nS 1
.Ft "void"
.Fn widget_init "void *widget, const char *type, const void *widget_ops" "int flags"
.nr nS 0
.Pp
The
.Fn widget_init
function initializes a generic
.Nm
structure.
Acceptable
.Fa flags
include:
.Pp
.Bd -literal
#define WIDGET_FOCUSABLE          0x01  /* Able to grab focus */
#define WIDGET_FOCUSED            0x02  /* Holds focus (optimization) */
#define WIDGET_UNFOCUSED_MOTION   0x04  /* Unfocused mousemotion */
#define WIDGET_UNFOCUSED_BUTTONUP 0x08  /* Unfocused mousebuttonup */
#define WIDGET_CLIPPING           0x10  /* Enable clipping */
#define WIDGET_WFILL              0x20  /* Fill available width */
#define WIDGET_HFILL              0x40  /* Fill available height */
.Ed
.Pp
Only widgets with the
.Dv WIDGET_FOCUSABLE
flag are able to gain keyboard and mousemotion focus.
If the flags
.Dv WIDGET_UNFOCUSED_MOTION
and
.Dv WIDGET_UNFOCUSED_BUTTONUP
are set, the widget will always receive
.Sq window-mousemotion
and
.Sq window-mousebuttonup
events, even if it's not holding focus.
.Pp
.Dv WIDGET_CLIPPING
arranges for a clipping rectangle (as set by
.Xr SDL_SetClipRect 3 )
to surround the widget area for the duration of the draw operation.
.Pp
The
.Dv WIDGET_WFILL
and
.Dv WIDGET_HFILL
flags indicate to container widgets that the widget wishes to allocate the
remaining width or height inside the container area.
.Pp
The
.Fa widget_ops
argument to
.Fn widget_init
is a pointer to the following structure:
.Bd -literal
struct widget_ops {
	const struct object_ops obops;          /* Generic object(3) ops */
	void (*draw)(void *p);                  /* Rendering routine */
	void (*scale)(void *p, int w, int h);   /* Size request routine */
};
.Ed
.Sh GEOMETRY MANAGEMENT
The
.Va scale
operation is invoked to set the size of a widget.
With
.Fa w ,
.Fa h
arguments of -1,
.Va scale
is expected to choose a default, minimum geometry sufficient to display the
widget aesthetically.
.Pp
Containers set the
.Va w ,
.Va h
geometries of their children prior to invoking their
.Va scale
operation (with arguments of
.Va w ,
.Va h ) .
Containers also set the
.Va x ,
.Va y
coordinates of their children but this does not need to be done with
.Fa w ,
.Fa h
arguments of -1.
.Pp
Widgets must not make any assumptions about their own position inside their
parent container.
.Sh FOCUS STATE
.nr nS 1
.Ft "int"
.Fn widget_holds_focus "void *widget"
.Pp
.Ft "void"
.Fn widget_focus "void *widget"
.nr nS 0
.Pp
The
.Fn widget_holds_focus
function returns 1 if a widget (as well as its parents) holds the keyboard
and mousemotion focus.
.Pp
The
.Fn widget_focus
function moves the keyboard/mousemotion focus over the given widget
(and its parents).
.Pp
A widget holding the keyboard/mousemotion focus receives keyboard and
mousemotion events.
The widget may also change its appearance depending on its focus state.
Some primitive routines such as
.Fn primitive.box
alter their appearance slightly depending on the focus state.
.Pp
Internally, the window focus is independent from the widget focus (the
highest window on the stack always holds focus).
The
.Fn WINDOW_FOCUSED
macro may be used to determine the focus state of a given window.
.Sh COORDINATES
.nr nS 1
.Ft int
.Fn widget_area "void *widget" "int x" "int y"
.Pp
.Ft int
.Fn widget_relative_area "void *widget" "int x" "int y"
.nr nS 0
.Pp
The
.Fn widget_area
function returns 1 if absolute view coordinates
.Fa x
and
.Fa y
are inside the area allocated by the widget.
.Fn widget_relative_area
evaluates to 1 if widget-relative view coordinates
.Fa x
and
.Fa y
are inside the widget area.
.Sh RENDERING AND PRIMITIVES
The
.Va draw
operation, if not NULL, is expected to render the given widget and its
children to the video display.
.Pp
The
.Fn primitives.*
functions are 2D primitives (and some higher-level drawing routines)
specially designed for widgets.
For a more general vector graphics API, look into OpenGL or
Agar's
.Xr vg 3
library.
.Pp
The coordinates for the
.Fn primitives.*
functions are given in pixels and are
relative to the parent (container) widget, and the
.Fa ncolor
argument is an index into the widget's color array (which is constructed
from
.Fn widget_map_color
and
.Fn widget_push_color ) .
.Pp
Primitive functions are members of the
.Va primitives
structure since the underlying functions may be selected at run-time.
For instance, appropriate OpenGL routines are substituted for the
direct video primitives in OpenGL mode.
.Pp
.nr nS 1
.Ft void
.Fn widget_blit "void *widget" "SDL_Surface *src" "int x" "int y"
.Pp
.Ft void
.Fn widget_put_pixel "void *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn primitives.box "void *widget" "int x" "int y" "int w" "int h" "int z" "int ncolor"
.Pp
.Ft void
.Fn primitives.box_chamfered "void *widget" "SDL_Rect *r" "int z" "int radius" "int ncolor"
.Pp
.Ft void
.Fn primitives.frame "void *widget" "int x" "int y" "int w" "int h" "int ncolor"
.Pp
.Ft void
.Fn primitives.circle "void *widget" "int x" "int y" "int radius" "int ncolor"
.Pp
.Ft void
.Fn primitives.circle2 "void *widget" "int x" "int y" "int radius" "int ncolor"
.Pp
.Ft void
.Fn primitives.line "void *widget" "int x1" "int y1" "int x2" "int y2" "int ncolor"
.Pp
.Ft void
.Fn primitives.line2 "void *widget" "int x1" "int y1" "int x2" "int y2" "int ncolor"
.Pp
.Ft void
.Fn primitives.rect_outlined "void *widget, int x, int y, int w, int h" "int ncolor"
.Pp
.Ft void
.Fn primitives.rect_filled "void *widget, int x, int y, int w, int h" "int ncolor"
.nr nS 0
The
.Fn widget_blit
function performs a surface blit from
.Fa src
to the video display at the given widget coordinates.
.Pp
The
.Fn widget_put_pixel
function writes a pixel of value
.Fa color
at the given widget coordinates, without checking the clipping rectangle.
.Pp
.Fn primitives.box
draws a 3D-style box of size
.Fa w ,
.Fa h ,
with a depth of
.Fa z
pixels.
The
.Fn primitive.box_chamfered
variant draws a 3D-style box with the two top edges chamfered to the
given
.Fa radius .
.Pp
For both these routines, the background color is varied slightly depending
on the focus state of the widget.
.Pp
.Fn primitives.frame
draws a 3D-style frame of size
.Fa w ,
.Fa h .
.Pp
.Fn primitives.circle
draws a circle with the origin at
.Fa x ,
.Fa y
and a radius of
.Fa radius
pixels.
.Pp
.Fn primitives.line
draws a line from
.Fa x1 ,
.Fa y1
to
.Fa x2 ,
.Fa y2 .
.Fn primitives.line2
is a variant which draws two lines with a slight color difference
(for simple 3D-style effects).
.Pp
.Fn primitives.rect_outlined
draws a rectangle outline of
.Fa w ,
.Fa h .
.Pp
.Fn primitives.rect_filled
draws a filled rectangle of size
.Fa w ,
.Fa h .
.Sh BINDINGS
The
.Nm widget
structure contains a list of pointers to variables which the widget will
access directly.
Widget bindings eliminate the need for event handlers for widgets manipulating
variables of primitive data types.
For example, the
.Xr scrollbar 3
widget defines
.Sq value ,
.Sq min
and
.Sq max
as bindings to integral or floating point values and
.Xr textbox 3
edits a
.Dv WIDGET_STRING
binding.
Whenever the variable changes, the value displayed by the widget is
updated automatically.
The widget also writes directly to the variable.
.Pp
All widgets provide default bindings, which point to data allocated and
initialized by the widget itself.
.Fn widget_bind
is called to override those default bindings.
.nr nS 1
.Ft "struct widget_binding *"
.Fn widget_bind "void *widget, const char *binding" "enum widget_binding_type type, ..."
.Pp
.Ft "struct widget_binding *"
.Fn widget_get_binding "void *widget" "const char *binding" "void *res"
.Pp
.Ft void
.Fn widget_binding_lock "struct widget_binding *binding"
.Pp
.Ft void
.Fn widget_binding_unlock "struct widget_binding *binding"
.Pp
.Ft int
.Fn widget_get_bool "void *widget" "const char *binding"
.Pp
.Ft int
.Fn widget_get_int "void *widget" "const char *binding"
.Pp
.Ft "u_int"
.Fn widget_get_uint "void *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn widget_get_uint8 "void *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn widget_get_sint8 "void *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn widget_get_uint16 "void *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn widget_get_sint16 "void *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn widget_get_uint32 "void *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn widget_get_sint32 "void *widget" "const char *binding"
.Pp
.Ft float
.Fn widget_get_float "void *widget" "const char *binding"
.Pp
.Ft double
.Fn widget_get_double "void *widget" "const char *binding"
.Pp
.Ft "char *"
.Fn widget_get_string "void *widget" "const char *binding"
.Pp
.Ft size_t
.Fn widget_copy_string "void *widget, const char *binding, char *dst" \
                       "size_t dst_size"
.Pp
.Ft void
.Fn widget_set_bool "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_int "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn widget_set_uint "void *widget" "const char *binding" "u_int i"
.Pp
.Ft void
.Fn widget_set_uint8 "void *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn widget_set_sint8 "void *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn widget_set_uint16 "void *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn widget_set_sint16 "void *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn widget_set_uint32 "void *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn widget_set_sint32 "void *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn widget_set_float "void *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn widget_set_double "void *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn widget_set_string "void *widget" "const char *binding" "const char *s"
.Pp
.nr nS 0
The
.Fn widget_bind
function either overrides or creates a new binding.
Correct values for the
.Fa type
argument include:
.Bd -literal
enum widget_binding_type {
	WIDGET_NONE,
	WIDGET_BOOL,
	WIDGET_UINT,
	WIDGET_INT,
	WIDGET_UINT8,
	WIDGET_SINT8,
	WIDGET_UINT16,
	WIDGET_SINT16,
	WIDGET_UINT32,
	WIDGET_SINT32,
	WIDGET_FLOAT,
	WIDGET_DOUBLE,
	WIDGET_STRING,
	WIDGET_PROP
}
.Ed
.Pp
The meaning of the following arguments depend on the type:
.Bl -tag -width "WIDGET_STRING "
.It WIDGET_PROP
Translate a
.Xr prop 3
value transparently.
.Pp
.Bl -tag -width "struct object *obj " -compact
.It "struct object *obj"
Object holding the property.
.It "const char *key"
Property key.
.El
.It WIDGET_STRING
Fixed-size, NUL-terminated string.
.Pp
.Bl -tag -width "pthread_mutex_t *lock " -compact
.It "pthread_mutex_t *lock"
Lock to acquire, or NULL.
.It "char *text"
Fixed-size, NUL-terminated string.
.It "size_t bufsize"
Total buffer size in bytes.
.El
.Pp
.Bl -tag -width "pthread_mutex_t *lock " -compact
.It "pthread_mutex_t *lock"
Lock to acquire, or NULL.
.It "size_t bufsize"
Total buffer size in bytes.
.El
.It WIDGET_*
Other types of data.
.Pp
.Bl -tag -width "pthread_mutex_t *lock " -compact
.It "pthread_mutex_t *lock"
Lock to acquire, or NULL.
.It "void *p"
Pointer to the data.
.El
.El
.Pp
The
.Fn widget_get_binding
function returns a matching binding (locked), or NULL if none was found.
If a binding was found, a pointer to it is written in the
.Fa res
argument.
.Fn widget_binding_unlock
should be called when done manipulating the data.
.Pp
The
.Fn widget_get_*
and
.Fn widget_set_*
variants manipulate the bound values atomically.
.Pp
The
.Fn widget_get_string
function returns a copy of the string (or NULL on failure).
.Fn widget_copy_string
copies up to
.Fa dst_size
- 1 bytes from the string to
.Fa dst ,
NUL-terminating the result and returning the number of bytes that would
have been copied if
.Fa dst_size
was unlimited.
.Sh THREAD SAFETY
In event context, the widgets can assume that their parent window is locked,
and internal properties of other widgets inside the same window can be
manipulated (for widgets inside other windows, explicit locking is required).
.Pp
The visibility of any window may be altered, and new windows may be attached
immediately.
In event context, window detach operations are deferred until processing of
the current event is complete.
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "void"
The widget is now visible.
.It Fn widget-hidden "void"
The widget is no longer visible.
.It Fn widget-gainfocus "void"
The widget now holds focus inside its parent container.
This event originates from the parent container object.
.It Fn widget-lostfocus "void"
The widget no longer holds focus.
.It Fn widget-bound "struct widget_binding *binding"
A widget binding has been added or modified.
.El
.Sh TROUBLETONS
The atomic
.Fn widget_get_*
and
.Fn widget_set_*
functions should probably be removed in favor of
.Fn widget_get_binding .
.Pp
Windows should attach to any type of widget, not only other windows.
.Sh SEE ALSO
.Xr agar 3 ,
.Xr window 3 ,
.Xr bitmap 3 ,
.Xr box 3 ,
.Xr button 3 ,
.Xr checkbox 3 ,
.Xr combo 3 ,
.Xr fspinbutton 3 ,
.Xr graph 3 ,
.Xr hbox 3 ,
.Xr label 3 ,
.Xr mapview 3 ,
.Xr palette 3 ,
.Xr radio 3 ,
.Xr scrollbar 3 ,
.Xr spinbutton 3 ,
.Xr textbox 3 ,
.Xr titlebar 3 ,
.Xr tlist 3 ,
.Xr ucombo 3 ,
.Xr vbox 3
.Sh HISTORY
The
.Nm
interface first appeared in Agar 1.0.
