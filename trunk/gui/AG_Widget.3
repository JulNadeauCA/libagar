.\" Copyright (c) 2002-2007 Hypertriton, Inc. <http://hypertriton.com/>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt AG_WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <agar/core.h>
#include <agar/gui.h>
.Ed
.Sh DESCRIPTION
A graphical user interface on the Agar platform is described as a tree of
.Nm
objects.
.Pp
Every widget has a local coordinate system and occupies a rectangular
area of pixels which was allocated by the parent widget (windows are
themselves a subclass of
.Nm ,
see
.Xr AG_Window 3
for details).
.Pp
The Agar GUI library is open, such that new, custom widgets may be implemented
(or derived from existing widget classes) as part of user applications, very
conveniently.
.Pp
The widget tree describes the relation between different widgets.
For example the
.Xr AG_Table 3
widget attaches two
.Xr AG_Scrollbar 3
widgets at specific positions in its own area, and sizes them accordingly.
.Pp
Widgets use the
.Xr AG_Event 3
system extensively to generate and handle many types of events.
.Pp
To reduce GUI-related code bloat to an absolute minimum (and also to simplify
its isolation), Agar widgets use a system of
.Sq bindings
such that widgets can directly access (read or write) specific data, without
the need for events.
For example, the 
.Xr AG_Scrollbar 3
widget provides a set of bindings named
.Sq value ,
.Sq min ,
.Sq max
and
.Sq visible
which, in the current implementation, can be attached to variables of
different integer and floating-point types.
The available bindings are always documented in the
.Dq BINDINGS
section of the widget's manual page.
.Sh INHERITANCE HIERARCHY
.Xr AG_Object 3 ->
.Nm .
.Sh CLASS OPERATIONS
The
.Ft AG_WidgetClass
structure adds some operations to
.Ft AG_ObjectClass :
.Bd -literal
typedef struct ag_widget_class {
	struct ag_object_class _inherit;
	void (*draw)(void *p);
	void (*size_request)(void *, AG_SizeReq *);
	int  (*size_allocate)(void *, const AG_SizeAlloc *);
} AG_WidgetClass;
.Ed
.Pp
The
.Va draw
operation (if not NULL) is responsible for rendering the widget.
Throughout the documentation, the
.Va draw
operation is referred to as the
.Sq rendering context ,
and some functions such as
.Fn AG_WidgetBlitSurface
are not safe to invoke in any other context.
.Pp
The
.Va size_request
option queries the widget for an initial, preferred geometry, without any
guarantee that the request will be satisfied.
For example, a
.Xr AG_Label 3
widget might return the expected size in pixels of the rendered label's text.
.Pp
The
.Va size_allocate
function notifies the widget that it has been allocated a new size or position
within its parent.
The widget is not allowed to modify the allocation, but if
.Va size_allocate
returns -1, the special flag
.Dv AG_WIDGET_UNDERSIZE
is automatically set, preventing
.Va draw
from being invoked at all.
.Sh WIDGET SIZING
.nr nS 1
.Ft "void"
.Fn AG_WidgetSizeReq "AG_Widget *widget" "AG_SizeReq *req"
.Pp
.Ft "int"
.Fn AG_WidgetSizeAlloc "AG_Widget *widget" "AG_SizeAlloc *alloc"
.Pp
.nr nS 0
The
.Ft AG_SizeReq
and
.Ft AG_SizeAlloc
structures are defined as follows:
.Bd -literal
typedef struct ag_size_req {
	int w, h;			/* Requested geometry in pixels */
} AG_SizeReq;

typedef struct ag_size_alloc {
	int w, h;			/* Allocated geometry in pixels */
	int x, y;			/* Allocated position in pixels */
} AG_SizeAlloc;
.Ed
.Pp
The
.Fn AG_WidgetSizeReq
function invokes the
.Va size_request
operation of the widget and returns its size requisition into
.Fa req .
.Fn AG_WidgetSizeAlloc
allocates the given position and geometry of the widget.
These functions are generally used in the
.Va size_request
and
.Va size_allocate
functions of container widgets.
.Sh INPUT STATE
The input state of a widget determines whether the user is allowed to
modify whatever data the widget is accessing.
The way it is implemented is widget-specific.
In the case of read-only type widgets such as
.Xr AG_Label 3 ,
the input state is irrelevant.
.Pp
.nr nS 1
.Ft "void"
.Fn AG_WidgetEnable "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetDisable "AG_Widget *widget"
.Pp
.Ft "int"
.Fn AG_WidgetEnabled "AG_Widget *widget"
.Pp
.Ft "int"
.Fn AG_WidgetDisabled "AG_Widget *widget"
.Pp
.nr nS 0
The
.Fn AG_WidgetEnable
function allows
.Fa widget
to receive user input.
.Fn AG_WidgetDisable
disables user input.
.Pp
The
.Fn AG_WidgetEnabled
and
.Fn AG_WidgetDisabled
macros evaluate whether the given widget is enabled for input.
.Sh FOCUS STATE
The focus state of a widget controls both its appearance and enables the
reception of specific types of events.
A focused widget (in a currently focused window) will receive mouse events
.Sq window-mousemotion ,
.Sq window-mousebuttonup ,
as well as keyboard events
.Sq window-keyup
and
.Sq window-keydown .
.Pp
Note that any widget can still receive those events regardless of focus
state, using
.Dv AG_WIDGET_UNFOCUSED_*
flags, such as
.Dv AG_WIDGET_UNFOCUSED_MOTION
and
.Dv AG_WIDGET_UNFOCUSED_BUTTONUP .
.Pp
.nr nS 1
.Ft "int"
.Fn AG_WidgetFocused "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFocus "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetUnfocus "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFindFocused "AG_Window *win"
.Pp
.nr nS 0
The
.Fn AG_WidgetFocused
macro evaluates to 1 if a widget holds focus inside of its parent.
.Pp
The
.Fn AG_WidgetFocus
function moves the keyboard/mousemotion focus over the given widget
and its parents.
.Fn AG_WidgetUnfocus
removes the focus state from the given widget and its children.
.Pp
The
.Fn AG_WidgetFindFocused
function searches the given window for a focused widget and returns a pointer
to it if it was found, or NULL otherwise.
With threads, the return value is only valid as long as the
.Xr AG_View 3
VFS is locked.
.Sh COORDINATES
.nr nS 1
.Ft int
.Fn AG_WidgetArea "AG_Widget *widget" "int x" "int y"
.Pp
.Ft int
.Fn AG_WidgetRelativeArea "AG_Widget *widget" "int x" "int y"
.Pp
.nr nS 0
The
.Fn AG_WidgetArea
function returns 1 if absolute view coordinates
.Fa x
and
.Fa y
are inside the area allocated by the widget.
.Fn AG_WidgetRelativeArea
evaluates to 1 if widget-relative view coordinates
.Fa x
and
.Fa y
are inside the widget area.
.Sh BLITTING SURFACES
These functions manage blitting of graphical surfaces.
They are designed specifically for use in GUI widgets.
The
.Fn AG_WidgetBlit*
routines must all be invoked from rendering context (i.e., the
.Fa draw
operation of widgets), and may not be used in any other context.
.Pp
.nr nS 1
.Ft void
.Fn AG_WidgetBlit "AG_Widget *widget" "SDL_Surface *src" "int x" "int y"
.Pp
.Ft int
.Fn AG_WidgetMapSurface "AG_Widget *widget" "SDL_Surface *su"
.Pp
.Ft void
.Fn AG_WidgetReplaceSurface "AG_Widget *widget" "int surface_id" "SDL_Surface *newSurface"
.Pp
.Ft void
.Fn AG_WidgetUnmapSurface "AG_Widget *widget" "int surface_id"
.Pp
.Ft void
.Fn AG_WidgetUpdateSurface "AG_Widget *widget" "int surface_id"
.Pp
.Ft void
.Fn AG_WidgetBlitFrom "AG_Widget *dstWidget" "AG_Widget *srcWidget" "int surface_id" "SDL_Rect *rs" "int x" "int y"
.Pp
.Ft void
.Fn AG_WidgetBlitSurface "AG_Widget *widget" "int surface_id" "int x" "int y"
.Pp
.nr nS 0
The
.Fn AG_WidgetBlit
function performs a software->hardware blit from the SDL surface
.Fa src
to the video display at the given widget coordinates.
.Fn AG_WidgetBlit
must invoked in rendering context.
.Pp
Software to hardware blits are slow, so the
.Fn AG_WidgetMapSurface
interface provides a way to take advantage of hardware->hardware blits.
If a texture unit is available, a hardware texture corresponding to the
given surface will be used.
The function returns a surface name.
Under multithreading,
.Fn AG_WidgetMapSurface
may be invoked from any context, but the returned name is only valid as
long as the widget is locked (see
.Xr AG_ObjectLock 3 ) .
.Pp
.Fn AG_WidgetReplaceSurface
replaces the contents of a previously-mapped surface with the contents of
.Fa newSurface .
.Pp
.Fn AG_WidgetUnmapSurface
destroys the given surface mapping.
It is equivalent to invoking
.Fn AG_WidgetReplaceSurface
with a NULL surface.
The function is safe to use from any context.
.Pp
It is important to note that in OpenGL mode,
.Fn AG_WidgetReplaceSurface
and
.Fn AG_WidgetUnmapSurface
will not immediately delete any previous texture associated with the previous
surface.
Instead, it will queue the delete operation for future execution from
rendering context, as required by thread safety.
.Pp
The
.Fn AG_WidgetUpdateSurface
function should be invoked whenever a mapped surface is changed.
If hardware surfaces are supported, it will cause an upload of the software
surface to the hardware (otherwise it is a no-op).
.Pp
The
.Fn AG_WidgetBlitFrom
function renders a previously mapped (possibly hardware) surface from the
source widget
.Fa srcWidget
(using source rectangle
.Fa rs )
onto the destination widget
.Fa dstWidget ,
at coordinates
.Fa x ,
.Fa y .
This function must be invoked in rendering context.
.Pp
The
.Fn AG_WidgetBlitSurface
variant invokes
.Fa AG_WidgetBlitFrom
with the same argument for both
.Fa srcWidget
and
.Fa dstWidget
(and
.Fa rs
set to NULL).
.Sh RENDERING AND PRIMITIVES
These functions are designed specifically for use in GUI widgets.
They must be called from the
.Fa draw
functions of widgets exclusively and may not be used in any other context.
.Pp
.nr nS 1
.Ft void
.Fn AG_WidgetPushClipRect "AG_Widget *widget" "AG_Rect r"
.Pp
.Ft void
.Fn AG_WidgetPopClipRect "AG_Widget *widget"
.Pp
.Ft void
.Fn AG_WidgetPushCursor "AG_Widget *widget" "int cursor"
.Pp
.Ft void
.Fn AG_WidgetPopCursor "AG_Widget *widget"
.Pp
.Ft void
.Fn AG_WidgetPutPixel32 "AG_Widget *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn AG_WidgetPutPixel32OrClip "AG_Widget *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn AG_WidgetPutPixelRGB "AG_Widget *widget" "int x" "int y" "Uint8 red" "Uint8 green" "Uint8 blue"
.Pp
.Ft void
.Fn AG_WidgetPutPixelRGBOrClip "AG_Widget *widget" "int x" "int y" "Uint8 red" "Uint8 green" "Uint8 blue"
.Pp
.Ft void
.Fn AG_WidgetBlendPixelRGBA "AG_Widget *widget" "int x" "int y" "Uint8 color[4]" "AG_BlendFn blendFn"
.Pp
.Ft void
.Fn AG_WidgetBlendPixel32 "AG_Widget *widget" "int x" "int y" "Uint32 pixel" "AG_BlendFn blendFn"
.Pp
.nr nS 0
The
.Fn AG_WidgetPushClipRect
function creates a clipping rectangle over the given area (given in
widget coordinates).
The current clipping rectangle is saved and can be restored by calling
.Fn AG_WidgetPopClipRect .
In SDL mode, the temporary rectangle is set by
.Xr SDL_SetClipRect 3 .
In OpenGL mode,
.Xr glClipPlane 3
is used.
It is not safe to call these two functions anywhere outside of a widget
.Va draw
operation.
.Pp
The
.Fn AG_WidgetPushCursor
function changes the active cursor, saving the previous one.
The argument is an index into the global
.Va agCursors
array.
The
.Fn AG_WidgetPopCursor
restores the previously saved cursor.
.Pp
.Fn AG_WidgetPutPixel32
function writes a pixel of value
.Fa color
at the given widget coordinates.
If the target pixel would lie outside of the video display, this function is
a no-op.
The
.Fn AG_WidgetPutPixel32OrClip
variant uses the clipping rectangle of the widget instead.
The variants
.Fn AG_WidgetPutPixelRGB
and
.Fn AG_WidgetPutPixelRGBAOrClip
accept a series of 8-bit color component values instead of a pixel value.
.Pp
The
.Fn AG_WidgetBlendPixelRGBA
function blends the specified RGB components with the pixel at the specified
coordinates
.Fa x ,
.Fa y
on the display.
The
.Fa color 
array specifies the 8-bit RGB components and a 8-bit source alpha value.
The pixels are blended according to the given function
.Fn blendFn ,
which may be one of:
.Bd -literal
typedef enum ag_blend_func {
	AG_ALPHA_OVERLAY,	/* dA = sA+dA (emulated in GL mode) */
	AG_ALPHA_SRC,		/* dA = sA */
	AG_ALPHA_DST,		/* dA = dA */
	AG_ALPHA_ONE_MINUS_DST,	/* dA = 1-dA */
	AG_ALPHA_ONE_MINUS_SRC	/* dA = 1-sA */
} AG_BlendFn;
.Ed
.Sh GRAPHICS PRIMITIVES
These primitives are designed specifically for use in GUI widgets.
They must be called from the
.Fa draw
functions of widgets exclusively and may not be used in any other context.
.Pp
The coordinates for all of the
.Fn AG_Draw*
functions are given in pixels and are relative to the specified widget.
Unless otherwise noted, the
.Fa c
arguments are indices into the global GUI color array (see
.Xr AG_Colors 3 ).
.Pp
.nr nS 1
.Ft void
.Fn AG_DrawBox "AG_Widget *widget" "AG_Rect r" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawBoxRounded "AG_Widget *widget" "AG_Rect r" "int z" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawFrame "AG_Widget *widget" "AG_Rect r" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawCircle "AG_Widget *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawCircle2 "AG_Widget *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawLine "AG_Widget *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawLine2 "AG_Widget *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawLineH "AG_Widget *widget" "int x1" "int x2" "int y" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawLineV "AG_Widget *widget" "int x" "int y1" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawRectOutline "AG_Widget *widget, AG_Rect r" "Uint32 c"
.Pp
.Ft void
.Fn AG_DrawRectFIlled "AG_Widget *widget, AG_Rect r" "Uint32 c"
.Pp
.nr nS 0
.Fn AG_DrawBox
draws a 3D-style box, where 
.Fa z
indicates the
.Sq depth
in pixels.
The
.Fn AG_DrawBoxRounded
variant renders the two top edges as rounded to the given
.Fa radius .
.Pp
.Fn AG_DrawFrame
draws a 3D-style frame.
.Pp
.Fn AG_DrawCircle
draws a circle with the origin at
.Fa x ,
.Fa y
and a radius of
.Fa radius
pixels.
.Pp
.Fn AG_DrawLine
scan-converts a line segment going from point
.Fa x1 ,
.Fa y1
to point
.Fa x2 ,
.Fa y2 .
The variants
.Fn AG_DrawLineH
and
.Fn AG_DrawLineV
render horizontal and vertical line segments, respectively.
.Fn AG_DrawLine2
renders two line segments for a 3D-style effect.
.Pp
.Fn AG_DrawRectOutline
draws the outline of a rectangle.
.Pp
.Fn AG_DrawRectFilled
fills a rectangle of pixels.
.Sh BINDINGS
Each widget has a list of named
.Sq bindings ,
which allow variables of specific types to be read or written by the widget
directly, eliminating the need for event handler functions in many situations.
.Pp
For example, the
.Xr AG_Scrollbar 3
widget defines three values named
.Sq value ,
.Sq min
and
.Sq max ,
which may be bound to both integral and floating point variables.
.Xr AG_Textbox 3
defines a string value which accepts a pointer to a fixed-size text buffer
(and the size of that buffer).
.Pp
.nr nS 1
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetBind "AG_Widget *widget, const char *binding" "enum ag_widget_binding_type type, ..."
.Pp
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetGetBinding "AG_Widget *widget" "const char *binding" "void *res"
.Pp
.Ft "int"
.Fn AG_WidgetCopyBinding "AG_Widget *dst_widget" "const char *dst_binding" "AG_WidgetBinding *src_binding"
.Pp
.Ft void
.Fn AG_WidgetLockBinding "AG_WidgetBinding *binding"
.Pp
.Ft void
.Fn AG_WidgetUnlockBinding "AG_WidgetBinding *binding"
.Pp
.Ft "void"
.Fn AG_WidgetBindBool "AG_Widget *widget" "const char *binding" "int *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindInt "AG_Widget *widget" "const char *binding" "int *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint "AG_Widget *widget" "const char *binding" "Uint *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint8 "AG_Widget *widget" "const char *binding" "Uint8 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint8 "AG_Widget *widget" "const char *binding" "Sint8 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint16 "AG_Widget *widget" "const char *binding" "Uint16 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint16 "AG_Widget *widget" "const char *binding" "Sint16 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint32 "AG_Widget *widget" "const char *binding" "Uint32 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint32 "AG_Widget *widget" "const char *binding" "Sint32 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint64 "AG_Widget *widget" "const char *binding" "Uint64 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint64 "AG_Widget *widget" "const char *binding" "Sint64 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindFloat "AG_Widget *widget" "const char *binding" "float *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindDouble "AG_Widget *widget" "const char *binding" "double *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindPointer "AG_Widget *widget" "const char *binding" "void **p"
.Pp
.Ft "void"
.Fn AG_WidgetBindProp "AG_Widget *widget" "const char *binding" "AG_Object *obj" "const char *prop_name"
.Pp
.Ft "void"
.Fn AG_WidgetBindString "AG_Widget *widget" "const char *binding" "char *p" "size_t len"
.Pp
.Ft "void"
.Fn AG_WidgetBindProp "AG_Widget *widget" "const char *binding" "AG_Object *obj" "const char *propKey"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag "AG_Widget *widget" "const char *binding" "int *p" "int bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag8 "AG_Widget *widget" "const char *binding" "Uint8 *p" "Uint8 bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag16 "AG_Widget *widget" "const char *binding" "Uint16 *p" "Uint16 bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag32 "AG_Widget *widget" "const char *binding" "Uint32 *p" "Uint32 bitmask"
.Pp
.Ft int
.Fn AG_WidgetBool "AG_Widget *widget" "const char *binding"
.Pp
.Ft int
.Fn AG_WidgetInt "AG_Widget *widget" "const char *binding"
.Pp
.Ft "Uint"
.Fn AG_WidgetUint "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn AG_WidgetUint8 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn AG_WidgetSint8 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn AG_WidgetUint16 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn AG_WidgetSint16 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn AG_WidgetUint32 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn AG_WidgetSint32 "AG_Widget *widget" "const char *binding"
.Pp
.Ft float
.Fn AG_WidgetFloat "AG_Widget *widget" "const char *binding"
.Pp
.Ft double
.Fn AG_WidgetDouble "AG_Widget *widget" "const char *binding"
.Pp
.Ft "char *"
.Fn AG_WidgetString "AG_Widget *widget" "const char *binding"
.Pp
.Ft size_t
.Fn AG_WidgetCopyString "AG_Widget *widget, const char *binding, char *dst" "size_t dst_size"
.Pp
.Ft void
.Fn AG_WidgetSetBool "AG_Widget *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetInt "AG_Widget *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetUint "AG_Widget *widget" "const char *binding" "Uint i"
.Pp
.Ft void
.Fn AG_WidgetSetUint8 "AG_Widget *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetSint8 "AG_Widget *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetUint16 "AG_Widget *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetSint16 "AG_Widget *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetUint32 "AG_Widget *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetSint32 "AG_Widget *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetFloat "AG_Widget *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn AG_WidgetSetDouble "AG_Widget *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn AG_WidgetSetString "AG_Widget *widget" "const char *binding" "const char *s"
.Pp
.Ft void
.Fn AG_WidgetSetPointer "AG_Widget *widget" "const char *binding" "void *p"
.Pp
.nr nS 0
The
.Fn AG_WidgetBind
function either overrides or creates a new binding.
Correct values for the
.Fa type
argument include:
.Pp
.Bd -literal
enum ag_widget_binding_type {
	AG_WIDGET_NONE,
	AG_WIDGET_BOOL,
	AG_WIDGET_UINT,
	AG_WIDGET_INT,
	AG_WIDGET_UINT8,
	AG_WIDGET_SINT8,
	AG_WIDGET_UINT16,
	AG_WIDGET_SINT16,
	AG_WIDGET_UINT32,
	AG_WIDGET_SINT32,
	AG_WIDGET_UINT64,
	AG_WIDGET_SINT64,
	AG_WIDGET_FLOAT,
	AG_WIDGET_DOUBLE,
	AG_WIDGET_LONG_DOUBLE,
	AG_WIDGET_STRING,
	AG_WIDGET_POINTER,
	AG_WIDGET_PROP,
	AG_WIDGET_FLAG,
	AG_WIDGET_FLAG8,
	AG_WIDGET_FLAG16,
	AG_WIDGET_FLAG32
}
.Ed
.Pp
The meaning of the following arguments depend on the type:
.Bl -tag -width "AG_WIDGET_STRING "
.It Dv AG_WIDGET_PROP
Translate an
.Xr AG_Prop 3
value transparently.
.Bl -tag -width "const char *key " -compact
.It Ft AG_Object *obj
Object holding the property.
.It Ft const char *key
Property key.
.El
.It Dv AG_WIDGET_STRING
Fixed-size, NUL-terminated string.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft char *text
Fixed-size, NUL-terminated string.
.It Ft size_t bufsize
Total buffer size in bytes.
.El
.It Dv AG_WIDGET_FLAG
One or more bits in a natural integer.
.Bl -tag -width "Uint bitmask " -compact
.It Ft Uint value
Flags value.
.It Ft Uint bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG8
One or more bits in a 8-bit integer.
.Bl -tag -width "Uint8 bitmask " -compact
.It Ft Uint8 value
Flags value.
.It Ft Uint8 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG16
One or more bits in a 16-bit integer.
.Bl -tag -width "Uint16 bitmask " -compact
.It Ft Uint16 value
Flags value.
.It Ft Uint16 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG32
One or more bits in a 32-bit integer.
.Bl -tag -width "Uint32 bitmask " -compact
.It Ft Uint32 value
Flags value.
.It Ft Uint32 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_*
Other types of data.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft void *p
Pointer to the data.
.El
.El
.Pp
Note that the
.Dv AG_WIDGET_UINT64
and
.Dv AG_WIDGET_SINT64
types are only implemented if
.Dv AG_HAVE_64BIT
is defined, and
.Dv AG_WIDGET_LONG_DOUBLE
requires
.Dv AG_HAVE_LONG_DOUBLE .
.Pp
The
.Fn AG_WidgetGetBinding
function returns a matching binding (locked), or NULL if none was found.
If a binding was found, a pointer to it is written in the
.Fa res
argument.
.Fn AG_WidgetUnlockBinding
should be called when done manipulating the data.
.Pp
The
.Fn AG_WidgetCopyBinding
function copies the data (ie. type, pointer values) of the binding
.Fa src_binding
to
.Fa dst_binding .
The destination binding must already exist.
The function returns 0 on success, -1 if an error occured.
.Pp
.Fn AG_WidgetSet_*
are simply variants of
.Fa AG_WidgetBind
without the
.Fa type
argument.
.Pp
The
.Fn AG_WidgetGet_*
variants return the current value of the given binding.
For thread safety, it is usually necessary to use
.Fn AG_WidgetGetBinding ,
which locks the binding value, requiring the caller to unlock it after use.
.Fn AG_WidgetString
returns a copy of the string (or NULL on failure).
.Fn AG_WidgetCopyString
copies up to
.Fa dst_size
- 1 bytes from the string to
.Fa dst ,
NUL-terminating the result and returning the number of bytes that would
have been copied if
.Fa dst_size
was unlimited.
.Sh MISCELLANEOUS
.nr nS 1
.Ft "AG_Window *"
.Fn AG_WidgetParentWindow "AG_Widget *widget"
.Pp
.Ft "AG_Widget *"
.Fn AG_WidgetFind "AG_Display *view" "const char *name"
.Pp
.Ft "AG_Widget *"
.Fn AG_WidgetFindPoint "const char *classMask" "int x" "int y"
.Pp
.Ft "AG_Widget *"
.Fn AG_WidgetFindRect "const char *classMask" "int x" "int y" "int w" "int h"
.Pp
.Ft "void"
.Fn AG_SetStyle "AG_Widget *widget" "AG_Style *style"
.Pp
.nr nS 0
.Fn AG_WidgetParentWindow
searches the parent objects of the given widget for an
.Xr AG_Window 3
(or a subclass of it).
If one is found, it is returned, otherwise the function returns NULL.
With threads, the return value is only valid as long as the view is locked
(see
.Xr AG_View 3 ) .
.Pp
.Fn AG_WidgetFind
searches for a given widget by name, given an absolute path,
and returns a pointer to the widget or NULL.
.Pp
.Fn AG_WidgetFindPoint
searches for a widget matching the given class mask enclosing the point
specified in display (pixel) coordinates.
The
.Fn AG_WidgetFindRect
variant requires that the widget enclose the specified rectangle.
.Pp
With threads, the return value of
.Fn AG_WidgetFind ,
.Fn AG_WidgetFindPoint
and
.Fn AG_WidgetFindRect
is only accurate as long as the
.Xr AG_View 3
VFS is locked.
.Pp
The
.Fn AG_SetStyle
function changes the style/theme associated with a widget.
See
.Xr AG_Style 3
for more information about styles.
Note that child widgets automatically inherit the style associated with
their parent.
.Sh THREAD SAFETY
Agar-GUI is thread-safe on a fine-grained level, so it is safe to make GUI
calls from different threads (unless documented otherwise in the widget's
manual page).
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "void"
The widget is now visible.
.It Fn widget-hidden "void"
The widget is no longer visible.
.It Fn widget-enabled "void"
Input state has been enabled with
.Xr AG_WidgetEnable 3 .
.It Fn widget-disabled "void"
Input state has been disabled with
.Xr AG_WidgetDisable 3 .
.It Fn widget-moved "void"
The widget (or one of its parents) has been moved.
.It Fn widget-gainfocus "void"
The widget now holds focus inside its parent container.
This event originates from the parent container object.
.It Fn widget-lostfocus "void"
The widget no longer holds focus.
.It Fn widget-bound "AG_WidgetBinding *binding"
A widget binding has been added or modified.
.El
.Sh STRUCTURE DATA
.Bl -tag -width "int cx2, cy2 "
.It Ft Uint flags
Option flags (see
.Dq FLAGS
section below).
.It Ft int x, y
Pixel coordinates of the widget relative to its parent.
.It Ft int w, h
Dimensions of the widget in pixels.
.It Ft int cx, cy
Absolute view coordinates of the upper left corner of the widget.
.It Ft int cx2, cy2
Absolute view coordinates of the lower right corner of the widget.
.It Ft int redraw
If
.Dv AG_WIDGET_STATIC
is set, a value of 1 causes the widget to be redrawn.
.El
.Sh FLAGS
The
.Va flags
member of the
.Nm
structure accepts the following flags:
.Bl -tag -width "AG_WIDGET_UNFOCUSED_BUTTONDOWN "
.It AG_WIDGET_HFILL
Hint to container widgets that in a vertical packing, this widget can expand
to fill all remaining space.
.It AG_WIDGET_VFILL
Hint to container widgets that in a horizontal packing, this widget can expand
to fill all remaining space.
.It AG_WIDGET_CLIPPING
Automatically set a temporary clipping rectangle to surround the widget
area during rendering.
Note that widgets can also request clipping rectangles using
.Fn AG_WidgetPushClipRect
and
.Fn AG_WidgetPopClipRect .
.It AG_WIDGET_HIDE
Disable rendering of this widget (does not affect widget's children).
.It AG_WIDGET_DISABLED
Meaning is widget-specific but it generally disables user input.
Flag is read-only and must be set via
.Fn AG_WidgetDisable
and
.Fn AG_WidgetEnable 
(see
.Dq INPUT STATE
section below for more details).
.It AG_WIDGET_FOCUSABLE
The widget can grab the focus.
.It AG_WIDGET_UNFOCUSED_MOTION
Receive
.Sq window-mousemotion
events unconditionally (focus is required by default).
.It AG_WIDGET_UNFOCUSED_BUTTONUP
Receive
.Sq window-mousebuttonup
events unconditionally (focus is required by default).
.It AG_WIDGET_UNFOCUSED_BUTTONDOWN
Receive
.Sq window-mousebuttonup
events unconditionally (focus is required by default).
.It AG_WIDGET_CATCH_TAB
When the user presses the
.Dv TAB
key, generate normal
.Sq window-keydown
and
.Sq window-keyup
events.
Without this flag,
.Dv TAB
is used to change the focus to the next widget.
.El
.Sh EXAMPLES
See
.Pa demos/widgets
in the Agar source distribution.
.Sh SEE ALSO
.Xr AG_Style 3 ,
.Xr AG_View 3 ,
.Xr AG_Window 3
.Sh HISTORY
The
.Nm
interface first appeared in Agar 1.0.
