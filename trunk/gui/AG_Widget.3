.\" Copyright (c) 2002-2007 Hypertriton, Inc. <http://hypertriton.com/>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <agar/gui.h>
.Ed
.Sh DESCRIPTION
A graphical user interface on the Agar platform is described as a tree of
.Nm
objects.
.Pp
Every widget has a local coordinate system and occupies a rectangular
area of pixels which was allocated by the parent widget (windows are
themselves a subclass of
.Nm ,
see
.Xr AG_Window 3
for details).
.Pp
The Agar GUI library is open, such that new, custom widgets may be implemented
(or derived from existing widget classes) as part of user applications, very
conveniently.
.Pp
The widget tree describes the relation between different widgets.
For example the
.Xr AG_Table 3
widget attaches two
.Xr AG_Scrollbar 3
widgets at specific positions in its own area, and sizes them accordingly.
.Pp
Widgets use the
.Xr AG_Event 3
system extensively to generate and handle many types of events.
.Pp
To reduce GUI-related code bloat to an absolute minimum (and also to simplify
its isolation), Agar widgets use a system of
.Sq bindings
such that widgets can directly access (read or write) specific data, without
the need for events.
For example, the 
.Xr AG_Scrollbar 3
widget provides a set of bindings named
.Sq value ,
.Sq min ,
.Sq max
and
.Sq visible
which, in the current implementation, can be attached to variables of
different integer and floating-point types.
The available bindings are always documented in the
.Dq BINDINGS
section of the widget's manual page.
.Sh INHERITANCE HIERARCHY
.Xr AG_Object 3 ->
.Nm .
.Sh INITIALIZATION
.nr nS 1
.Ft "void"
.Fn AG_WidgetInit "AG_Widget *widget" "const AG_Widget *widget_ops" "Uint flags"
.Pp
.Ft "AG_Widget *"
.Fn AG_WidgetFind "AG_Display *view" "const char *name"
.nr nS 0
The
.Fn AG_WidgetInit
function initializes a preallocated
.Nm
structure.
.Pp
Acceptable
.Fa flags
include:
.Pp
.Bd -literal
#define AG_WIDGET_FOCUSABLE		0x0001 /* Can grab focus */
#define AG_WIDGET_UNFOCUSED_MOTION	0x0004 /* All motion events */
#define AG_WIDGET_UNFOCUSED_BUTTONUP	0x0008 /* All buttonup events */
#define AG_WIDGET_UNFOCUSED_BUTTONDOWN	0x0010 /* All buttondown events */
#define AG_WIDGET_CLIPPING		0x0020 /* Automatic clipping */
#define AG_WIDGET_HFILL			0x0040 /* Expand to fill width */
#define AG_WIDGET_VFILL			0x0080 /* Expand to fill height */
#define AG_WIDGET_HIDE			0x0200 /* Don't draw this widget */
#define AG_WIDGET_DISABLED		0x0400 /* Ignore user input (RO) */
#define AG_WIDGET_FOCUS_PARENT_WIN	0x1000 /* Auto focus parent win */
#define AG_WIDGET_EXPAND		(AG_WIDGET_HFILL|AG_WIDGET_VFILL)
.Ed
.Pp
The
.Dv AG_WIDGET_FOCUSABLE
flag indicates that this widget is able to gain focus
.Dv AG_WIDGET_FOCUSED
is a read-only flag indicating the actual focus state.
The special
.Dv AG_WIDGET_UNFOCUSED_*
flags are used to enable unconditional reception of events which are normally
destined only to focused widgets
(see the
.Dq FOCUS STATE
section below for more details on focus management).
.Pp
.Dv AG_WIDGET_CLIPPING
arranges for a temporary clipping rectangle to surround the widget's
allocated area for the duration of the draw operation.
Widgets can set clipping rectangles over specific areas with
.Fn AG_WidgetPushClipRect
and
.Fn AG_WidgetPopClipRect .
.Pp
The meaning of the
.Dv AG_WIDGET_HFILL
and
.Dv AG_WIDGET_VFILL
flags is container-widget-specific and indicates that the widget wishes to
use all remaining space horizontally or vertically inside the container.
.Pp
The
.Dv AG_WIDGET_HIDE
prevents the widget from being drawn.
If the widget has children, they are not affected by this flag.
.Pp
The meaning of the
.Dv AG_WIDGET_DISABLED
flag is widget-specific.
Typically, widgets with this flag do not allow user input.
This flag is read-only and must be set via
.Fn AG_WidgetDisable
and
.Fn AG_WidgetEnable 
(see
.Dq INPUT STATE
section below for more details).
.Pp
The
.Dv AG_WIDGET_FOCUS_PARENT_WIN
flag indicates that whenever the widget is focused,
.Xr AG_WindowFocus
should be invoked automatically on the widget's parent window (if it has one).
.Pp
The
.Fa widget_ops
argument to
.Fn AG_WidgetInit
is a pointer to the following structure:
.Pp
.Bd -literal
typedef struct ag_widget_ops {
	const AG_ObjectOps ops;                 /* Object operations */
	void (*draw)(void *p);                  /* Rendering routine */
	void (*scale)(void *p, int w, int h);   /* Size request routine */
} AG_WidgetOps;
.Ed
.Pp
The
.Va draw
operation (if not NULL) is responsible for rendering the widget
(see
.Dq RENDERING AND PRIMITIVES
below for functions useful in rendering).
If the current display is in OpenGL mode, the
.Va draw
function is able to perform OpenGL calls, although OpenGL code is rarely
seen in typical widgets, since they generally use the functions described
in the 
.Dq RENDERING AND PRIMITIVES
section, which all provide their own OpenGL/SDL abstraction.
OpenGL applications
tend to use
.Xr AG_GLView 3
and
.Xr SG_View 3
where an OpenGL context is needed.
.Pp
It is important to note that most GLs are not thread-safe, so OpenGL
calls in Agar are protected by a mutex (via
.Xr AG_LockGL 3
and
.Xr AG_UnlockGL 3 ) .
It is not necessary, however, for widget
.Va draw
operations to acquire this mutex since it is done by the event loop.
.Pp
The
.Va scale
operation requests that the widget sizes (or resizes) itself to the
given dimensions (see
.Dq GEOMETRY MANAGEMENT
below for more details).
.Pp
The
.Fn AG_WidgetFind
function searches for a given widget by name, given an absolute path,
and returns a pointer to the widget or NULL.
.Sh GEOMETRY MANAGEMENT
The
.Va scale
operation is invoked to set the size of a widget.
With
.Fa w ,
.Fa h
arguments of -1,
.Va scale
is expected to choose a default, minimum geometry sufficient to display the
widget aesthetically.
.Pp
Containers set the
.Va w ,
.Va h
geometries of their children prior to invoking their
.Va scale
operation (with arguments of
.Va w ,
.Va h ) .
Containers also set the
.Va x ,
.Va y
coordinates of their children but this does not need to be done with
.Fa w ,
.Fa h
arguments of -1.
.Pp
Widgets must not make any assumptions about their own position inside their
parent container.
.Sh INPUT STATE
.Pp
The input state of a widget determines whether the user is allowed to
modify whatever data the widget is accessing.
The way it is implemented is widget-specific.
In the case of read-only type widgets such as
.Xr AG_Label 3 ,
the input state is irrelevant.
.Pp
.nr nS 1
.Ft "void"
.Fn AG_WidgetEnable "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetDisable "AG_Widget *widget"
.Pp
.Ft "int"
.Fn AG_WidgetEnabled "AG_Widget *widget"
.Pp
.Ft "int"
.Fn AG_WidgetDisabled "AG_Widget *widget"
.Pp
.nr nS 0
The
.Fn AG_WidgetEnable
function allows
.Fa widget
to receive user input.
.Fn AG_WidgetDisable
disables user input.
.Pp
The
.Fn AG_WidgetEnabled
and
.Fn AG_WidgetDisabled
macros evaluate whether the given widget is enabled for input.
.Sh FOCUS STATE
.Pp
The focus state of a widget controls both its appearance and enables the
reception of specific types of events.
A focused widget (in a currently focused window) will receive mouse events
.Sq window-mousemotion ,
.Sq window-mousebuttonup ,
as well as keyboard events
.Sq window-keyup
and
.Sq window-keydown .
.Pp
Note that any widget can still receive those events regardless of focus
state, using
.Dv AG_WIDGET_UNFOCUSED_*
flags, such as
.Dv AG_WIDGET_UNFOCUSED_MOTION
and
.Dv AG_WIDGET_UNFOCUSED_BUTTONUP .
.Pp
.nr nS 1
.Ft "int"
.Fn AG_WidgetFocused "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFocus "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetUnfocus "AG_Widget *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFindFocused "AG_Window *win"
.Pp
.nr nS 0
The
.Fn AG_WidgetFocused
macro evaluates to 1 if a widget holds focus inside of its parent.
.Pp
The
.Fn AG_WidgetFocus
function moves the keyboard/mousemotion focus over the given widget
and its parents.
.Fn AG_WidgetUnfocus
removes the focus state from the given widget and its children.
.Pp
The
.Fn AG_WidgetFindFocused
function searches the given window for a focused widget and returns a pointer
to it if it was found, or NULL otherwise.
.Sh COORDINATES
.nr nS 1
.Ft int
.Fn AG_WidgetArea "AG_Widget *widget" "int x" "int y"
.Pp
.Ft int
.Fn AG_WidgetRelativeArea "AG_Widget *widget" "int x" "int y"
.Pp
.nr nS 0
The
.Fn AG_WidgetArea
function returns 1 if absolute view coordinates
.Fa x
and
.Fa y
are inside the area allocated by the widget.
.Fn AG_WidgetRelativeArea
evaluates to 1 if widget-relative view coordinates
.Fa x
and
.Fa y
are inside the widget area.
.Sh BLITTING SURFACES
.nr nS 1
.Ft void
.Fn AG_WidgetBlit "AG_Widget *widget" "SDL_Surface *src" "int x" "int y"
.Pp
.Ft int
.Fn AG_WidgetMapSurface "AG_Widget *widget" "SDL_Surface *su"
.Pp
.Ft void
.Fn AG_WidgetUnmapSurface "AG_Widget *widget" "int surface_id"
.Pp
.Ft void
.Fn AG_WidgetReplaceSurface "AG_Widget *widget" "int surface_id" "SDL_Surface *newSurface"
.Pp
.Ft void
.Fn AG_WidgetUpdateSurface "AG_Widget *widget" "int surface_id"
.Pp
.Ft void
.Fn AG_WidgetBlitFrom "AG_Widget *dstWidget" "AG_Widget *srcWidget" "int surface_id" "SDL_Rect *rs" "int x" "int y"
.Pp
.Ft void
.Fn AG_WidgetBlitSurface "AG_Widget *widget" "int surface_id" "int x" "int y"
.Pp
.nr nS 0
The
.Fn AG_WidgetBlit
function performs a software->hardware blit from the SDL surface
.Fa src
to the video display at the given widget coordinates.
.Pp
Software to hardware blits are slow, so the
.Fn AG_WidgetMapSurface
interface provides a way to take advantage of hardware->hardware blits.
If a texture unit is available, this function causes the given surface
to be uploaded to the graphics hardware and a per-widget surface handle
is returned.
.Fn AG_WidgetUnmapSurface
destroys the given surface mapping.
.Pp
.Fn AG_WidgetReplaceSurface
replaces the contents of a previously-mapped surface with the contents of
.Fa newSurface .
.Pp
The
.Fn AG_WidgetUpdateSurface
function should be invoked whenever a mapped surface is changed.
If hardware surfaces are supported, it will cause an upload of the software
surface to the hardware (otherwise it is a no-op).
.Pp
The
.Fn AG_WidgetBlitFrom
function renders a previously mapped (possibly hardware) surface from the
source widget
.Fa srcWidget
(using source rectangle
.Fa rs )
onto the destination widget
.Fa dstWidget ,
at coordinates
.Fa x ,
.Fa y .
.Pp
The
.Fn AG_WidgetBlitSurface
variant invokes
.Fa AG_WidgetBlitFrom
with the same argument for both
.Fa srcWidget
and
.Fa dstWidget
(and
.Fa rs
set to NULL).
.Sh RENDERING AND PRIMITIVES
.nr nS 1
.Ft void
.Fn AG_WidgetPushClipRect "AG_Widget *widget" "int x" "int y" "Uint w" "Uint h"
.Pp
.Ft void
.Fn AG_WidgetPopClipRect "AG_Widget *widget"
.Pp
.Ft void
.Fn AG_WidgetPushCursor "AG_Widget *widget" "int cursor"
.Pp
.Ft void
.Fn AG_WidgetPopCursor "AG_Widget *widget"
.Pp
.Ft void
.Fn AG_WidgetPutPixel32 "AG_Widget *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn AG_WidgetPutPixel32OrClip "AG_Widget *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn AG_WidgetPutPixelRGB "AG_Widget *widget" "int x" "int y" "Uint8 red" "Uint8 green" "Uint8 blue"
.Pp
.Ft void
.Fn AG_WidgetPutPixelRGBOrClip "AG_Widget *widget" "int x" "int y" "Uint8 red" "Uint8 green" "Uint8 blue"
.Pp
.Ft void
.Fn AG_WidgetBlendPixelRGBA "AG_Widget *widget" "int x" "int y" "Uint8 color[4]" "AG_BlendFn blendFn"
.Pp
.Ft void
.Fn AG_WidgetBlendPixel32 "AG_Widget *widget" "int x" "int y" "Uint32 pixel" "AG_BlendFn blendFn"
.Pp
.nr nS 0
The
.Fn AG_WidgetPushClipRect
function creates a clipping rectangle over the given area (given in
widget coordinates).
The current clipping rectangle is saved and can be restored by calling
.Fn AG_WidgetPopClipRect .
In SDL mode, the temporary rectangle is set by
.Xr SDL_SetClipRect 3 .
In OpenGL mode,
.Xr glClipPlane 3
is used.
It is not safe to call these two functions anywhere outside of a widget
.Va draw
operation.
.Pp
The
.Fn AG_WidgetPushCursor
function changes the active cursor, saving the previous one.
The argument is an index into the global
.Va agCursors
array.
The
.Fn AG_WidgetPopCursor
restores the previously saved cursor.
.Pp
.Fn AG_WidgetPutPixel32
function writes a pixel of value
.Fa color
at the given widget coordinates.
If the target pixel would lie outside of the video display, this function is
a no-op.
The
.Fn AG_WidgetPutPixel32OrClip
variant uses the clipping rectangle of the widget instead.
The variants
.Fn AG_WidgetPutPixelRGB
and
.Fn AG_WidgetPutPixelRGBAOrClip
accept a series of 8-bit color component values instead of a pixel value.
.Pp
The
.Fn AG_WidgetBlendPixelRGBA
function blends the specified RGB components with the pixel at the specified
coordinates
.Fa x ,
.Fa y
on the display.
The
.Fa color 
array specifies the 8-bit RGB components and a 8-bit source alpha value.
The pixels are blended according to the given function
.Fn blendFn ,
which may be one of:
.Bd -literal
typedef enum ag_blend_func {
	AG_ALPHA_OVERLAY,	/* dA = sA+dA (emulated in GL mode) */
	AG_ALPHA_SRC,		/* dA = sA */
	AG_ALPHA_DST,		/* dA = dA */
	AG_ALPHA_ONE_MINUS_DST,	/* dA = 1-dA */
	AG_ALPHA_ONE_MINUS_SRC	/* dA = 1-sA */
} AG_BlendFn;
.Ed
.Sh GRAPHICS PRIMITIVES
.Pp
All of the following functions are called from the widget
.Va draw
operation (they are not safe to use in another context), to render primitives
that are designed specifically for use in GUI widgets.
.Pp
These functions are called via the
.Va agPrim
structure to allow switching between different primitive functions at run time
or specifying alternate user primitives.
By default, the built-in primitive functions are selected depending on whether
the display uses direct video or OpenGL.
.Pp
The coordinates for all the
.Fn agPrim.*
functions are given in pixels and are relative to the specified widget.
Unless otherwise noted, the
.Fa c
arguments are indices into the global GUI color array (see
.Xr AG_Colors 3 ).
.Pp
.nr nS 1
.Ft void
.Fn agPrim.box "AG_Widget *widget" "int x" "int y" "int w" "int h" "int z" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.box_chamfered "AG_Widget *widget" "SDL_Rect *r" "int z" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.frame "AG_Widget *widget" "int x" "int y" "int w" "int h" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.circle "AG_Widget *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.circle2 "AG_Widget *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.line "AG_Widget *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.line2 "AG_Widget *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.hline "AG_Widget *widget" "int x1" "int x2" "int y" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.vline "AG_Widget *widget" "int x" "int y1" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.rect_outlined "AG_Widget *widget, int x, int y, int w, int h" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.rect_filled "AG_Widget *widget, int x, int y, int w, int h" "Uint32 c"
.Pp
.nr nS 0
.Pp
.Fn agPrim.box
draws a 3D-style box of size
.Fa w ,
.Fa h ,
with a depth of
.Fa z
pixels.
The
.Fn primitive.box_chamfered
variant draws a 3D-style box with the two top edges chamfered to the
given
.Fa radius .
.Pp
.Fn agPrim.frame
draws a 3D-style frame of size
.Fa w ,
.Fa h .
.Pp
.Fn agPrim.circle
draws a circle with the origin at
.Fa x ,
.Fa y
and a radius of
.Fa radius
pixels.
.Pp
.Fn agPrim.line
scan-converts a line segment going from point
.Fa x1 ,
.Fa y1
to point
.Fa x2 ,
.Fa y2 .
The variants
.Fn agPrim.hline
and
.Fn agPrim.vline
render horizontal and vertical line segments, respectively.
.Fn agPrim.line2
renders two line segments of different intensities.
.Pp
.Fn agPrim.rect_outlined
draws a rectangle outline of
.Fa w ,
.Fa h .
.Pp
.Fn agPrim.rect_filled
draws a filled rectangle of size
.Fa w ,
.Fa h .
.Sh BINDINGS
Each widget has a list of named
.Sq bindings ,
which allow variables of specific types to be read or written by the widget
directly, eliminating the need for event handler functions in many situations.
.Pp
For example, the
.Xr AG_Scrollbar 3
widget defines three values named
.Sq value ,
.Sq min
and
.Sq max ,
which may be bound to both integral and floating point variables.
.Xr AG_Textbox 3
defines a string value which accepts a pointer to a fixed-size text buffer
(and the size of that buffer).
.Pp
.nr nS 1
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetBind "AG_Widget *widget, const char *binding" "enum ag_widget_binding_type type, ..."
.Pp
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetGetBinding "AG_Widget *widget" "const char *binding" "void *res"
.Pp
.Ft "int"
.Fn AG_WidgetCopyBinding "AG_Widget *dst_widget" "const char *dst_binding" "void *src_widget" "const char *src_binding"
.Pp
.Ft void
.Fn AG_WidgetLockBinding "AG_WidgetBinding *binding"
.Pp
.Ft void
.Fn AG_WidgetUnlockBinding "AG_WidgetBinding *binding"
.Pp
.Ft "void"
.Fn AG_WidgetBindBool "AG_Widget *widget" "const char *binding" "int *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindInt "AG_Widget *widget" "const char *binding" "int *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint "AG_Widget *widget" "const char *binding" "Uint *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint8 "AG_Widget *widget" "const char *binding" "Uint8 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint8 "AG_Widget *widget" "const char *binding" "Sint8 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint16 "AG_Widget *widget" "const char *binding" "Uint16 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint16 "AG_Widget *widget" "const char *binding" "Sint16 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint32 "AG_Widget *widget" "const char *binding" "Uint32 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint32 "AG_Widget *widget" "const char *binding" "Sint32 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindUint64 "AG_Widget *widget" "const char *binding" "Uint64 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindSint64 "AG_Widget *widget" "const char *binding" "Sint64 *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindFloat "AG_Widget *widget" "const char *binding" "float *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindDouble "AG_Widget *widget" "const char *binding" "double *p"
.Pp
.Ft "void"
.Fn AG_WidgetBindPointer "AG_Widget *widget" "const char *binding" "void **p"
.Pp
.Ft "void"
.Fn AG_WidgetBindProp "AG_Widget *widget" "const char *binding" "AG_Object *obj" "const char *prop_name"
.Pp
.Ft "void"
.Fn AG_WidgetBindString "AG_Widget *widget" "const char *binding" "char *p" "size_t len"
.Pp
.Ft "void"
.Fn AG_WidgetBindProp "AG_Widget *widget" "const char *binding" "AG_Object *obj" "const char *propKey"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag "AG_Widget *widget" "const char *binding" "int *p" "int bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag8 "AG_Widget *widget" "const char *binding" "Uint8 *p" "Uint8 bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag16 "AG_Widget *widget" "const char *binding" "Uint16 *p" "Uint16 bitmask"
.Pp
.Ft "void"
.Fn AG_WidgetBindFlag32 "AG_Widget *widget" "const char *binding" "Uint32 *p" "Uint32 bitmask"
.Pp
.Ft int
.Fn AG_WidgetBool "AG_Widget *widget" "const char *binding"
.Pp
.Ft int
.Fn AG_WidgetInt "AG_Widget *widget" "const char *binding"
.Pp
.Ft "Uint"
.Fn AG_WidgetUint "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn AG_WidgetUint8 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn AG_WidgetSint8 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn AG_WidgetUint16 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn AG_WidgetSint16 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn AG_WidgetUint32 "AG_Widget *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn AG_WidgetSint32 "AG_Widget *widget" "const char *binding"
.Pp
.Ft float
.Fn AG_WidgetFloat "AG_Widget *widget" "const char *binding"
.Pp
.Ft double
.Fn AG_WidgetDouble "AG_Widget *widget" "const char *binding"
.Pp
.Ft "char *"
.Fn AG_WidgetString "AG_Widget *widget" "const char *binding"
.Pp
.Ft size_t
.Fn AG_WidgetCopyString "AG_Widget *widget, const char *binding, char *dst" "size_t dst_size"
.Pp
.Ft void
.Fn AG_WidgetSetBool "AG_Widget *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetInt "AG_Widget *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetUint "AG_Widget *widget" "const char *binding" "Uint i"
.Pp
.Ft void
.Fn AG_WidgetSetUint8 "AG_Widget *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetSint8 "AG_Widget *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetUint16 "AG_Widget *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetSint16 "AG_Widget *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetUint32 "AG_Widget *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetSint32 "AG_Widget *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetFloat "AG_Widget *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn AG_WidgetSetDouble "AG_Widget *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn AG_WidgetSetString "AG_Widget *widget" "const char *binding" "const char *s"
.Pp
.Ft void
.Fn AG_WidgetSetPointer "AG_Widget *widget" "const char *binding" "void *p"
.Pp
.nr nS 0
The
.Fn AG_WidgetBind
function either overrides or creates a new binding.
Correct values for the
.Fa type
argument include:
.Pp
.Bd -literal
enum ag_widget_binding_type {
	AG_WIDGET_NONE,
	AG_WIDGET_BOOL,
	AG_WIDGET_UINT,
	AG_WIDGET_INT,
	AG_WIDGET_UINT8,
	AG_WIDGET_SINT8,
	AG_WIDGET_UINT16,
	AG_WIDGET_SINT16,
	AG_WIDGET_UINT32,
	AG_WIDGET_SINT32,
	AG_WIDGET_UINT64,
	AG_WIDGET_SINT64,
	AG_WIDGET_FLOAT,
	AG_WIDGET_DOUBLE,
	AG_WIDGET_STRING,
	AG_WIDGET_POINTER,
	AG_WIDGET_PROP,
	AG_WIDGET_FLAG,
	AG_WIDGET_FLAG8,
	AG_WIDGET_FLAG16,
	AG_WIDGET_FLAG32
}
.Ed
.Pp
The meaning of the following arguments depend on the type:
.Bl -tag -width "AG_WIDGET_STRING "
.It Dv AG_WIDGET_PROP
Translate an
.Xr AG_Prop 3
value transparently.
.Bl -tag -width "const char *key " -compact
.It Ft AG_Object *obj
Object holding the property.
.It Ft const char *key
Property key.
.El
.It Dv AG_WIDGET_STRING
Fixed-size, NUL-terminated string.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft char *text
Fixed-size, NUL-terminated string.
.It Ft size_t bufsize
Total buffer size in bytes.
.El
.It Dv AG_WIDGET_FLAG
One or more bits in a natural integer.
.Bl -tag -width "Uint bitmask " -compact
.It Ft Uint value
Flags value.
.It Ft Uint bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG8
One or more bits in a 8-bit integer.
.Bl -tag -width "Uint8 bitmask " -compact
.It Ft Uint8 value
Flags value.
.It Ft Uint8 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG16
One or more bits in a 16-bit integer.
.Bl -tag -width "Uint16 bitmask " -compact
.It Ft Uint16 value
Flags value.
.It Ft Uint16 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_FLAG32
One or more bits in a 32-bit integer.
.Bl -tag -width "Uint32 bitmask " -compact
.It Ft Uint32 value
Flags value.
.It Ft Uint32 bitmask
Bitmask value.
.El
.It Dv AG_WIDGET_*
Other types of data.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft void *p
Pointer to the data.
.El
.El
.Pp
The
.Fn AG_WidgetGetBinding
function returns a matching binding (locked), or NULL if none was found.
If a binding was found, a pointer to it is written in the
.Fa res
argument.
.Fn AG_WidgetUnlockBinding
should be called when done manipulating the data.
.Pp
The
.Fn AG_WidgetCopyBinding
function copies the data (ie. type, pointer values) of the binding
.Fa src_binding
to
.Fa dst_binding .
The destination binding must exist.
The function returns 0 on success, -1 if an error occured.
.Pp
.Fn AG_WidgetSet_*
are simply variants of
.Fa AG_WidgetBind
without the
.Fa type
argument.
.Pp
The
.Fn AG_WidgetGet_*
variants return the current value of the given binding.
For thread safety, it is usually necessary to use
.Fn AG_WidgetGetBinding ,
which locks the binding value, requiring the caller to unlock it after use.
.Fn AG_WidgetString
returns a copy of the string (or NULL on failure).
.Fn AG_WidgetCopyString
copies up to
.Fa dst_size
- 1 bytes from the string to
.Fa dst ,
NUL-terminating the result and returning the number of bytes that would
have been copied if
.Fa dst_size
was unlimited.
.Sh THREAD SAFETY
Agar-GUI is thread-safe on a fine-grained level, so it is safe to make GUI
calls from different threads (unless documented otherwise in the widget's
manual page).
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "void"
The widget is now visible.
.It Fn widget-hidden "void"
The widget is no longer visible.
.It Fn widget-moved "void"
The widget (or one of its parents) has been moved.
.It Fn widget-gainfocus "void"
The widget now holds focus inside its parent container.
This event originates from the parent container object.
.It Fn widget-lostfocus "void"
The widget no longer holds focus.
.It Fn widget-bound "AG_WidgetBinding *binding"
A widget binding has been added or modified.
.El
.Sh SEE ALSO
.Xr AG_Intro 3 ,
.Xr AG_View 3 ,
.Xr AG_Window 3
.Sh HISTORY
The
.Nm
interface first appeared in Agar 1.0.
.Sh BUGS
Atomic widget binding operations require the use of mutexes, read-write locks
are not yet supported.
