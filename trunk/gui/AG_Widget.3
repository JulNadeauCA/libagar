.\"	$Csoft: widget.3,v 1.66 2005/10/01 12:02:06 vedge Exp $
.\"
.\" Copyright (c) 2002-2006 CubeSoft Communications, Inc.
.\" <http://www.csoft.org>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
.\" INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
.\" (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
.\" STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
.\" IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd August 20, 2002
.Dt WIDGET 3
.Os
.ds vT Agar API Reference
.ds oS Agar 1.0
.Sh NAME
.Nm AG_Widget
.Nd agar widget framework
.Sh SYNOPSIS
.Bd -literal
#include <agar/gui.h>
.Ed
.Sh DESCRIPTION
The Agar
.Nm
class is the basic building block for implementing graphical interfaces.
An Agar graphical interface is a tree of objects derived from this class.
Every widget occupies a specific rectangle of pixels inside its parent.
The position and geometry of widgets on the screen is determined by
recursive transformations.
.Pp
Interactive widgets are graphical elements that the user interacts with
using the mouse or keyboard, for example
.Xr AG_Button 3
displays a standard push-button.
.Pp
Non-interactive widgets are generally
.Sq container
widgets whose sole purpose is to determine the position and geometry of its
child widgets using specific algorithms, for example
.Xr AG_Box 3
and
.Xr AG_Window 3 .
.Pp
It is common for interactive widgets to attach other widgets, for example
the
.Xr AG_Table 3
widget attaches a
.Xr AG_Scrollbar 3
widget at a specific position and sets its geometry accordingly.
.Pp
Widgets use the
.Xr AG_Event 3
system extensively to generate and handle many types of events.
Many Agar widgets also use
.Sq bindings
to directly read/write data of specific types, without the need for using
events.
For example, the 
.Xr AG_FSpinbutton 3
widget provides a binding called
.Sq value
which can be
.Ft double ,
.Ft float ,
.Ft int ,
.Ft Uint ,
.Ft Uint8 ,
etc.
This technique can significantly reduce GUI-related code bloat in applications.
.Sh INHERITANCE HIERARCHY
.Xr AG_Object 3 ->
.Nm .
.Sh INITIALIZATION
.nr nS 1
.Ft "void"
.Fn AG_WidgetInit "void *widget, const char *type, const void *widget_ops" "int flags"
.Pp
.nr nS 0
The
.Fn AG_WidgetInit
function initializes a
.Nm
structure.
Acceptable
.Fa flags
include:
.Pp
.Bd -literal
#define AG_WIDGET_FOCUSABLE		0x001 /* Can grab focus */
#define AG_WIDGET_FOCUSED		0x002 /* Holds focus */
#define AG_WIDGET_UNFOCUSED_MOTION	0x004 /* All motion events */
#define AG_WIDGET_UNFOCUSED_BUTTONUP	0x008 /* All buttonup events */
#define AG_WIDGET_UNFOCUSED_BUTTONDOWN	0x010 /* All buttondown events */
#define AG_WIDGET_CLIPPING		0x020 /* Automatic clipping */
#define AG_WIDGET_HFILL			0x040 /* Expand to fill width */
#define AG_WIDGET_VFILL			0x080 /* Expand to fill height */
#define AG_WIDGET_HIDE			0x200 /* Don't draw this widget */
.Ed
.Pp
Only widgets with the
.Dv AG_WIDGET_FOCUSABLE
flag are able to gain keyboard and mousemotion focus.
If the flags
.Dv AG_WIDGET_UNFOCUSED_MOTION
and
.Dv AG_WIDGET_UNFOCUSED_BUTTONUP
are set, the widget will always receive
.Sq window-mousemotion ,
and
.Sq window-mousebuttonup
events, even if it's not holding focus.
.Pp
.Dv AG_WIDGET_CLIPPING
arranges for a temporary clipping rectangle to surround the widget's
allocated area for the duration of the draw operation.
Widgets can set clipping rectangles over specific areas with
.Fn AG_WidgetPushClipRect
and
.Fn AG_WidgetPopClipRect .
.Pp
The
.Dv AG_WIDGET_HFILL
and
.Dv AG_WIDGET_VFILL
flags indicate to container widgets that the widget wishes to allocate the
remaining width or height inside the container area.
.Pp
The
.Fa widget_ops
argument to
.Fn AG_WidgetInit
is a pointer to the following structure:
.Pp
.Bd -literal
AG_WidgetOps {
	const AG_ObjectOps ops;                 /* Object operations */
	void (*draw)(void *p);                  /* Rendering routine */
	void (*scale)(void *p, int w, int h);   /* Size request routine */
};
.Ed
.Sh GEOMETRY MANAGEMENT
The
.Va scale
operation is invoked to set the size of a widget.
With
.Fa w ,
.Fa h
arguments of -1,
.Va scale
is expected to choose a default, minimum geometry sufficient to display the
widget aesthetically.
.Pp
Containers set the
.Va w ,
.Va h
geometries of their children prior to invoking their
.Va scale
operation (with arguments of
.Va w ,
.Va h ) .
Containers also set the
.Va x ,
.Va y
coordinates of their children but this does not need to be done with
.Fa w ,
.Fa h
arguments of -1.
.Pp
Widgets must not make any assumptions about their own position inside their
parent container.
.Sh FOCUS STATE
.nr nS 1
.Ft "int"
.Fn AGWIDGET_FOCUSED "void *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFocus "void *widget"
.Pp
.Ft "void"
.Fn AG_WidgetUnfocus "void *widget"
.Pp
.Ft "void"
.Fn AG_WidgetFindFocused "AG_Window *win"
.Pp
.nr nS 0
The
.Fn AGWIDGET_FOCUSED
macro returns 1 if a widget holds focus inside of its parent.
.Pp
The
.Fn AG_WidgetFocus
function moves the keyboard/mousemotion focus over the given widget
(and its parents).
.Pp
A widget holding the keyboard/mousemotion focus receives keyboard and
mousemotion events.
The widget may also change its appearance depending on its focus state.
.Pp
The
.Fn AG_WidgetFindFocused
function searches the given window for a focused widget and returns a pointer
to it if it was found, or NULL otherwise.
.Sh COORDINATES
.nr nS 1
.Ft int
.Fn AG_WidgetArea "void *widget" "int x" "int y"
.Pp
.Ft int
.Fn AG_WidgetRelativeArea "void *widget" "int x" "int y"
.Pp
.nr nS 0
The
.Fn AG_WidgetArea
function returns 1 if absolute view coordinates
.Fa x
and
.Fa y
are inside the area allocated by the widget.
.Fn AG_WidgetRelativeArea
evaluates to 1 if widget-relative view coordinates
.Fa x
and
.Fa y
are inside the widget area.
.Sh RENDERING AND PRIMITIVES
The
.Va draw
operation, if not NULL, is expected to render the given widget and its
children to the video display.
.Pp
The
.Fn agPrim.*
functions implement 2D primitives designed specifically for widgets.
.Pp
The coordinates for the
.Fn agPrim.*
functions are given in pixels and are
relative to the parent (container) widget, and the
.Fa c
arguments are indices into the global GUI color array (see
.Xr AG_Colors 3 ).
.Pp
Primitive functions are members of the
.Va agPrim
structure since the underlying functions may be selected at run-time.
For instance, appropriate OpenGL routines are substituted for the
direct video agPrim in OpenGL mode.
.Pp
.nr nS 1
.Ft void
.Fn AG_WidgetPushClipRect "void *widget" "int x" "int y" "Uint w" "Uint h"
.Pp
.Ft void
.Fn AG_WidgetPopClipRect "void *widget"
.Pp
.Ft void
.Fn AG_WidgetPushCursor "void *widget" "int cursor"
.Pp
.Ft void
.Fn AG_WidgetPopCursor "void *widget"
.Pp
.Ft void
.Fn AG_WidgetBlit "void *widget" "SDL_Surface *src" "int x" "int y"
.Pp
.Ft void
.Fn AG_WidgetPutPixel "void *widget" "int x" "int y" "Uint32 color"
.Pp
.Ft void
.Fn agPrim.box "void *widget" "int x" "int y" "int w" "int h" "int z" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.box_chamfered "void *widget" "SDL_Rect *r" "int z" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.frame "void *widget" "int x" "int y" "int w" "int h" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.circle "void *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.circle2 "void *widget" "int x" "int y" "int radius" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.line "void *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.line2 "void *widget" "int x1" "int y1" "int x2" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.hline "void *widget" "int x1" "int x2" "int y" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.vline "void *widget" "int x" "int y1" "int y2" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.rect_outlined "void *widget, int x, int y, int w, int h" "Uint32 c"
.Pp
.Ft void
.Fn agPrim.rect_filled "void *widget, int x, int y, int w, int h" "Uint32 c"
.Pp
.nr nS 0
The
.Fn AG_WidgetPushClipRect
function creates a clipping rectangle over the given area (given in
widget coordinates).
The current clipping rectangle is saved and can be restored by calling
.Fn AG_WidgetPopClipRect .
In SDL mode, the temporary rectangle is set by
.Xr SDL_SetClipRect 3 .
In OpenGL mode,
.Xr glClipPlane 3
is used.
.Pp
The
.Fn AG_WidgetPushCursor
function changes the active cursor, saving the previous one.
The argument is an index into the global
.Va agCursors
array.
The
.Fn AG_WidgetPopCursor
restores the previously saved cursor.
.Pp
The
.Fn AG_WidgetBlit
function performs a surface blit from
.Fa src
to the video display at the given widget coordinates.
.Pp
The
.Fn AG_WidgetPutPixel
function writes a pixel of value
.Fa color
at the given widget coordinates, without checking the clipping rectangle.
.Pp
.Fn agPrim.box
draws a 3D-style box of size
.Fa w ,
.Fa h ,
with a depth of
.Fa z
pixels.
The
.Fn primitive.box_chamfered
variant draws a 3D-style box with the two top edges chamfered to the
given
.Fa radius .
.Pp
.Fn agPrim.frame
draws a 3D-style frame of size
.Fa w ,
.Fa h .
.Pp
.Fn agPrim.circle
draws a circle with the origin at
.Fa x ,
.Fa y
and a radius of
.Fa radius
pixels.
.Pp
.Fn agPrim.line
scan-converts a line segment going from point
.Fa x1 ,
.Fa y1
to point
.Fa x2 ,
.Fa y2 .
The variants
.Fn agPrim.hline
and
.Fn agPrim.vline
render horizontal and vertical line segments, respectively.
.Fn agPrim.line2
renders two line segments of different intensities.
.Pp
.Fn agPrim.rect_outlined
draws a rectangle outline of
.Fa w ,
.Fa h .
.Pp
.Fn agPrim.rect_filled
draws a filled rectangle of size
.Fa w ,
.Fa h .
.Sh BINDINGS
Each widget has a list of named
.Sq bindings ,
which allow variables of specific types to be read or written by the widget
directly, eliminating the need for event handler functions in many situations.
.Pp
For example, the
.Xr AG_Scrollbar 3
widget defines three values named
.Sq value ,
.Sq min
and
.Sq max ,
which may be bound to both integral and floating point variables.
.Xr AG_Textbox 3
defines a string value which accepts a pointer to a fixed-size text buffer
(and the size of that buffer).
.Pp
.nr nS 1
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetBind "void *widget, const char *binding" "enum ag_widget_binding_type type, ..."
.Pp
.Ft "AG_WidgetBinding *"
.Fn AG_WidgetGetBinding "void *widget" "const char *binding" "void *res"
.Pp
.Ft "int"
.Fn AG_WidgetCopyBinding "void *dst_widget" "const char *dst_binding" "void *src_widget" "const char *src_binding"
.Pp
.Ft void
.Fn AG_WidgetLockBinding "AG_WidgetBinding *binding"
.Pp
.Ft void
.Fn AG_WidgetUnlockBinding "AG_WidgetBinding *binding"
.Pp
.Ft int
.Fn AG_WidgetBool "void *widget" "const char *binding"
.Pp
.Ft int
.Fn AG_WidgetInt "void *widget" "const char *binding"
.Pp
.Ft "Uint"
.Fn AG_WidgetUint "void *widget" "const char *binding"
.Pp
.Ft Uint8
.Fn AG_WidgetUint8 "void *widget" "const char *binding"
.Pp
.Ft Sint8
.Fn AG_WidgetSint8 "void *widget" "const char *binding"
.Pp
.Ft Uint16
.Fn AG_WidgetUint16 "void *widget" "const char *binding"
.Pp
.Ft Sint16
.Fn AG_WidgetSint16 "void *widget" "const char *binding"
.Pp
.Ft Uint32
.Fn AG_WidgetUint32 "void *widget" "const char *binding"
.Pp
.Ft Sint32
.Fn AG_WidgetSint32 "void *widget" "const char *binding"
.Pp
.Ft float
.Fn AG_WidgetFloat "void *widget" "const char *binding"
.Pp
.Ft double
.Fn AG_WidgetDouble "void *widget" "const char *binding"
.Pp
.Ft "char *"
.Fn AG_WidgetString "void *widget" "const char *binding"
.Pp
.Ft size_t
.Fn AG_WidgetCopyString "void *widget, const char *binding, char *dst" "size_t dst_size"
.Pp
.Ft void
.Fn AG_WidgetSetBool "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetInt "void *widget" "const char *binding" "int i"
.Pp
.Ft void
.Fn AG_WidgetSetUint "void *widget" "const char *binding" "Uint i"
.Pp
.Ft void
.Fn AG_WidgetSetUint8 "void *widget" "const char *binding" "Uint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetSint8 "void *widget" "const char *binding" "Sint8 u8"
.Pp
.Ft void
.Fn AG_WidgetSetUint16 "void *widget" "const char *binding" "Uint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetSint16 "void *widget" "const char *binding" "Sint16 u16"
.Pp
.Ft void
.Fn AG_WidgetSetUint32 "void *widget" "const char *binding" "Uint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetSint32 "void *widget" "const char *binding" "Sint32 u32"
.Pp
.Ft void
.Fn AG_WidgetSetFloat "void *widget" "const char *binding" "float f"
.Pp
.Ft void
.Fn AG_WidgetSetDouble "void *widget" "const char *binding" "double d"
.Pp
.Ft void
.Fn AG_WidgetSetString "void *widget" "const char *binding" "const char *s"
.Pp
.nr nS 0
The
.Fn AG_WidgetBind
function either overrides or creates a new binding.
Correct values for the
.Fa type
argument include:
.Pp
.Bd -literal
enum ag_widget_binding_type {
	AG_WIDGET_NONE,
	AG_WIDGET_BOOL,
	AG_WIDGET_UINT,
	AG_WIDGET_INT,
	AG_WIDGET_UINT8,
	AG_WIDGET_SINT8,
	AG_WIDGET_UINT16,
	AG_WIDGET_SINT16,
	AG_WIDGET_UINT32,
	AG_WIDGET_SINT32,
	AG_WIDGET_FLOAT,
	AG_WIDGET_DOUBLE,
	AG_WIDGET_STRING,
	AG_WIDGET_PROP
}
.Ed
.Pp
The meaning of the following arguments depend on the type:
.Bl -tag -width "AG_WIDGET_STRING "
.It Dv AG_WIDGET_PROP
Translate an
.Xr AG_Prop 3
value transparently.
.Bl -tag -width "const char *key " -compact
.It Ft AG_Object *obj
Object holding the property.
.It Ft const char *key
Property key.
.El
.It Dv AG_WIDGET_STRING
Fixed-size, NUL-terminated string.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft char *text
Fixed-size, NUL-terminated string.
.It Ft size_t bufsize
Total buffer size in bytes.
.El
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft size_t bufsize
Total buffer size in bytes.
.El
.It Dv WIDGET_*
Other types of data.
.Bl -tag -width "AG_Mutex *lock " -compact
.It Ft AG_Mutex *lock
Lock to acquire, or NULL.
.It Ft void *p
Pointer to the data.
.El
.El
.Pp
The
.Fn AG_WidgetGetBinding
function returns a matching binding (locked), or NULL if none was found.
If a binding was found, a pointer to it is written in the
.Fa res
argument.
.Fn AG_WidgetUnlockBinding
should be called when done manipulating the data.
.Pp
The
.Fn AG_WidgetCopyBinding
function copies the data (ie. type, pointer values) of the binding
.Fa src_binding
to
.Fa dst_binding .
The destination binding must exist.
The function returns 0 on success, -1 if an error occured.
.Pp
The
.Fn AG_WidgetGet_*
and
.Fn AG_WidgetSet_*
variants manipulate the bound values atomically.
.Pp
The
.Fn AG_WidgetString
function returns a copy of the string (or NULL on failure).
.Fn AG_WidgetCopyString
copies up to
.Fa dst_size
- 1 bytes from the string to
.Fa dst ,
NUL-terminating the result and returning the number of bytes that would
have been copied if
.Fa dst_size
was unlimited.
.Sh THREAD SAFETY
In event context, the widgets can assume that their parent window is locked,
and internal properties of other widgets inside the same window can be
manipulated (for widgets inside other windows, explicit locking is required).
.Pp
The visibility of any window may be altered, and new windows may be attached
immediately.
In event context, window detach operations are deferred until processing of
the current event is complete.
.Sh EVENTS
The
.Nm
layer generates the following events:
.Pp
.Bl -tag -compact -width 2n
.It Fn widget-shown "void"
The widget is now visible.
.It Fn widget-hidden "void"
The widget is no longer visible.
.It Fn widget-moved "void"
The widget (or one of its parents) has been moved.
.It Fn widget-gainfocus "void"
The widget now holds focus inside its parent container.
This event originates from the parent container object.
.It Fn widget-lostfocus "void"
The widget no longer holds focus.
.It Fn widget-bound "AG_WidgetBinding *binding"
A widget binding has been added or modified.
.El
.Sh SEE ALSO
.Xr AG_Intro 3 ,
.Xr AG_View 3 ,
.Xr AG_Window 3
.Sh HISTORY
The
.Nm
interface first appeared in Agar 1.0.
.Sh BUGS
Atomic widget binding operations require the use of mutexes, read-write locks
are not supported.
