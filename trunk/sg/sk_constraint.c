/*
 * Copyright (c) 2007 Hypertriton, Inc. <http://hypertriton.com/>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * These functions implement placement of entities based on their constraints
 * with respect to either single entity or a set of two constrained entities.
 *
 * They are implemented as generic sketch instructions (which are usually
 * going to be generated by DOF analysis).
 *
 * Where there are multiple solutions, we optimize for least displacement
 * of the unknown entity.
 */ 

#include <config/have_opengl.h>
#ifdef HAVE_OPENGL

#include <core/core.h>

#include "sk.h"
#include "sk_constraint.h"

static int
PtFromDistantPt(SK_Constraint *ct, void *self, void *other)
{
	SG_Vector p1 = SK_NodeCoords(self);
	SG_Vector p2 = SK_NodeCoords(other);
	SG_Real theta;
	
	SG_VectorVectorAngle(p1, p2, &theta, NULL);
	SK_Identity(self);
	p2.x -= ct->ct_distance*Cos(theta);
	p2.y -= ct->ct_distance*Sin(theta);
	SK_Translatev(self, &p2);
	return (0);
}

static int
PtFromDistantLine(SK_Constraint *ct, void *self, void *other)
{
	SK_Line *L = other;
	SG_Vector pOrig = SK_NodeCoords(self);
	SG_Vector p1 = SK_NodeCoords(L->p1);
	SG_Vector p2 = SK_NodeCoords(L->p2);
	SG_Vector v, vd, s1, s2;
	SG_Real mag, u, theta;

	/* Find the closest point on the line. */
	vd = SG_VectorSubp(&p2, &p1);
	mag = SG_VectorDistance(p2, p1);
	u = ( ((pOrig.x - p1.x)*(p2.x - p1.x)) +
	      ((pOrig.y - p1.y)*(p2.y - p1.y)) ) / (mag*mag);
	if (u < 0.0 || u > 1.0) {
		if (ct->ct_distance == 0.0) {
			return (0);
		} else {
			AG_SetError("u = %f", u);
			return (-1);
		}
	} else {
		v = SG_VectorAdd(p1, SG_VectorScalep(&vd,u));
	}
	if (ct->ct_distance == 0.0) {
		SK_Identity(self);
		SK_Translatev(self, &v);
		return (0);
	}
	SG_VectorVectorAngle(p1, p2, &theta, NULL);
	theta += M_PI/2.0;
	s1.x = v.x + ct->ct_distance*Cos(theta);
	s1.y = v.y + ct->ct_distance*Sin(theta);
	s2.x = v.x - ct->ct_distance*Cos(theta);
	s2.y = v.y - ct->ct_distance*Sin(theta);
	
	SK_Identity(self);
	if (SG_VectorDistancep(&pOrig, &s1) <	/* Minimize displacement */
	    SG_VectorDistancep(&pOrig, &s2)) {
		SK_Translatev(self, &s1);
	} else {
		SK_Translatev(self, &s2);
	}
	return (0);
}

static int
PtFromDistantCircle(SK_Constraint *ct, void *self, void *other)
{
	SK_Point *p = self;
	SK_Circle *C1 = other;
	SG_Vector p1 = SK_NodeCoords(C1->p);
	
	SK_Identity(p);
	SK_Translatev(p, &p1);
	SK_Translate2(p, C1->r + ct->ct_distance, 0.0);
	return (0);
}

static int
LineFromDistantLine(SK_Constraint *ct, void *self, void *other)
{
	SK_Line *L = self;
	SK_Line *L1 = other;

	SK_MatrixCopy(L->p1, L1->p1);
	SK_MatrixCopy(L->p2, L1->p2);
	SK_Translate2(L->p1, ct->ct_distance, 0.0);
	SK_Translate2(L->p2, ct->ct_distance, 0.0);
	return (0);
}

static int
LineFromAngledLine(SK_Constraint *ct, void *self, void *other)
{
	SK_Line *L = self;
	SK_Line *L1 = other;

	SK_MatrixCopy(L->p1, L1->p1);
	SK_MatrixCopy(L->p2, L1->p2);
	SK_Rotatev(L->p1, ct->ct_angle);
	SK_Rotatev(L->p2, ct->ct_angle);
	return (0);
}

/*
 * Compute the position of a point relative to two fixed points from
 * distance/incidence constraints. This is a system of two quadratic
 * equations describing the intersection of two circles.
 */
static int
PtFromPtPt(void *self, SK_Constraint *ct1, void *n1, SK_Constraint *ct2,
    void *n2)
{
	SG_Vector pOrig = SK_NodeCoords(self);
	SG_Vector p1 = SK_NodeCoords(n1);
	SG_Vector p2 = SK_NodeCoords(n2);
	SG_Real d1 = (ct1->type == SK_DISTANCE) ? ct1->ct_distance : 0.0;
	SG_Real d2 = (ct2->type == SK_DISTANCE) ? ct2->ct_distance : 0.0;
	SG_Real d12 = SG_VectorDistancep(&p1, &p2);
	SG_Real a, h, b;
	SG_Vector p, s1, s2;

	dprintf("PtFromPtPt(%s,[%f:%s],[%f:%s])\n",
	    SK_NodeName(self),
	    ct1->ct_distance, SK_NodeName(n1),
	    ct2->ct_distance, SK_NodeName(n2));

	if (d12 > (d1+d2)) {
		char *name1 = SK_NodeName(n1);
		char *name2 = SK_NodeName(n2);
		AG_SetError("%s and %s are too far apart to satisfy "
		            "constraint: %.02f > (%.02f+%.02f)",
			    name1, name2, d12, d1, d2);
		Free(name1,0);
		Free(name2,0);
		return (-1);
	}
	if (d12 < SG_Fabs(d1-d2)) {
		char *name1 = SK_NodeName(n1);
		char *name2 = SK_NodeName(n2);
		AG_SetError("%s and %s are too close to satisfy "
		            "constraint: %.02f < |%.02f-%.02f|",
			    name1, name2, d12, d1, d2);
		Free(name1,0);
		Free(name2,0);
		return (-1);
	}

	a = (d1*d1 - d2*d2 + d12*d12) / (2.0*d12);
	h = Sqrt(d1*d1 - a*a);
	p = SG_VectorLERPp(&p1, &p2, a/d12);
	b = h/d12;

	s1.x = p.x - b*(p2.y - p1.y);
	s1.y = p.y + b*(p2.x - p1.x);
	s1.z = 0.0;
	s2.x = p.x + b*(p2.y - p1.y);
	s2.y = p.y - b*(p2.x - p1.x);
	s2.z = 0.0;

	SK_Identity(self);
	if (SG_VectorDistancep(&pOrig, &s1) <	/* Minimize displacement */
	    SG_VectorDistancep(&pOrig, &s2)) {
		SK_Translatev(self, &s1);
	} else {
		SK_Translatev(self, &s2);
	}
	return (0);
}

/*
 * Compute the position of a point relative to a known point and line.
 * This is a system of quadratic equations describing the intersection of
 * a line with a circle.
 */
static int
PtFromPtLine(void *self, SK_Constraint *ct1, void *n1,
    SK_Constraint *ct2, void *n2)
{
	SG_Vector pOrig = SK_NodeCoords(self);
	SG_Vector p = SK_NodeCoords(n1);
	SK_Line *L = n2;
	SG_Vector p1 = SK_NodeCoords(L->p1);
	SG_Vector p2 = SK_NodeCoords(L->p2);
	SG_Real d1 = (ct1->type == SK_DISTANCE) ? ct1->ct_distance : 0.0;
	SG_Real d2 = (ct2->type == SK_DISTANCE) ? ct2->ct_distance : 0.0;
	SG_Real a = (p2.x - p1.x)*(p2.x - p1.x) +
	            (p2.y - p1.y)*(p2.y - p1.y);
	SG_Real b = 2.0*( (p2.x - p1.x)*(p1.x - p.x) +
	                  (p2.y - p1.y)*(p1.y - p.y));
	SG_Real cc = p.x*p.x + p.y*p.y + p1.x*p1.x + p1.y*p1.y -
	             2.0*(p.x*p1.x + p.y*p1.y) - d1*d1;
	SG_Real deter = b*b - 4*a*cc;
	SG_Vector s[2];
	int nSolutions = 0;

	if (deter < 0.0) {
		dprintf("outside (det < 0)\n");
		goto fail;
	} else if (deter == 0.0) {
		/* TODO Tangent */
		dprintf("tangent (det==0)\n");
	} else {
		SG_Real e = Sqrt(deter);
		SG_Real u1 = (-b + e) / (2.0*a);
		SG_Real u2 = (-b - e) / (2.0*a);
		
		dprintf("e=%f, u1=%f, u2=%f\n", e, u1, u2);
		
		if ((u1 < 0.0 || u1 > 1.0) &&
		    (u2 < 0.0 || u2 > 1.0)) {
			if ((u1 < 0.0 && u2 < 0.0) ||
			    (u1 > 1.0 && u2 > 1.0)) {
				goto fail;
			} else {
				/* XXX */
				dprintf("u1=%f, u2=%f!\n", u1, u2);
			}
		} else {
			if (u1 >= 0.0 && u1 <= 1.0)
				s[nSolutions++] = SG_VectorLERPp(&p1,&p2,u1);
			if (u2 >= 0.0 && u2 <= 1.0)
				s[nSolutions++] = SG_VectorLERPp(&p1,&p2,u1);
		}
	}
	
	SK_Identity(self);
	if (nSolutions == 2) {
		if (SG_VectorDistancep(&pOrig, &s[0]) <
		    SG_VectorDistancep(&pOrig, &s[1])) {
			SK_Translatev(self, &s[0]);
		} else {
			SK_Translatev(self, &s[1]);
		}
	} else if (nSolutions == 1) {
		SK_Translatev(self, &s[0]);
	} else {
		dprintf("no solutions\n");
		goto fail;
	}
	return (0);
fail:
	{
		char *name1 = SK_NodeName(n1);
		char *name2 = SK_NodeName(n2);
		AG_SetError("%s and %s are too far apart to satisfy constraint",
			    name1, name2);
		Free(name1,0);
		Free(name2,0);
	}
	return (-1);
}

const SK_ConstraintPairFn skConstraintPairFns[] = {
	{ SK_DISTANCE,	 "Point:*", "Point:*",	PtFromDistantPt },
	{ SK_DISTANCE,	 "Point:*", "Line:*",	PtFromDistantLine },
	{ SK_DISTANCE,	 "Line:*",  "Line:*",	LineFromDistantLine },
	{ SK_ANGLE,	 "Line:*",  "Line:*",	LineFromAngledLine },
};
const SK_ConstraintRingFn skConstraintRingFns[] = {
	{
		"Point:*",
		SK_CONSTRAINT_ANY, "Point:*",
		SK_CONSTRAINT_ANY, "Point:*",
		PtFromPtPt
	}, {
		"Point:*",
		SK_CONSTRAINT_ANY, "Point:*",
		SK_CONSTRAINT_ANY, "Line:*",
		PtFromPtLine
	},
};

const int skConstraintPairFnCount = sizeof(skConstraintPairFns) /
                                    sizeof(skConstraintPairFns[0]);
const int skConstraintRingFnCount = sizeof(skConstraintRingFns) /
                                    sizeof(skConstraintRingFns[0]);

#endif /* HAVE_OPENGL */
